// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENGINESERVICES_RHMSG_H_
#define FLATBUFFERS_GENERATED_ENGINESERVICES_RHMSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace RHMsg {

struct EngineService;

struct SnapToGround;

struct SimStateRequest;

struct SimStateReply;

enum EngineServiceType {
  EngineServiceType_NONE = 0,
  EngineServiceType_SnapToGround = 1,
  EngineServiceType_SimStateRequest = 2,
  EngineServiceType_SimStateReply = 3,
  EngineServiceType_MIN = EngineServiceType_NONE,
  EngineServiceType_MAX = EngineServiceType_SimStateReply
};

inline EngineServiceType (&EnumValuesEngineServiceType())[4] {
  static EngineServiceType values[] = {
    EngineServiceType_NONE,
    EngineServiceType_SnapToGround,
    EngineServiceType_SimStateRequest,
    EngineServiceType_SimStateReply
  };
  return values;
}

inline const char **EnumNamesEngineServiceType() {
  static const char *names[] = {
    "NONE",
    "SnapToGround",
    "SimStateRequest",
    "SimStateReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameEngineServiceType(EngineServiceType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEngineServiceType()[index];
}

template<typename T> struct EngineServiceTypeTraits {
  static const EngineServiceType enum_value = EngineServiceType_NONE;
};

template<> struct EngineServiceTypeTraits<SnapToGround> {
  static const EngineServiceType enum_value = EngineServiceType_SnapToGround;
};

template<> struct EngineServiceTypeTraits<SimStateRequest> {
  static const EngineServiceType enum_value = EngineServiceType_SimStateRequest;
};

template<> struct EngineServiceTypeTraits<SimStateReply> {
  static const EngineServiceType enum_value = EngineServiceType_SimStateReply;
};

bool VerifyEngineServiceType(flatbuffers::Verifier &verifier, const void *obj, EngineServiceType type);
bool VerifyEngineServiceTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SimStateCommand {
  SimStateCommand_Query = 0,
  SimStateCommand_Start = 1,
  SimStateCommand_Pause = 2,
  SimStateCommand_Reset = 3,
  SimStateCommand_MIN = SimStateCommand_Query,
  SimStateCommand_MAX = SimStateCommand_Reset
};

inline SimStateCommand (&EnumValuesSimStateCommand())[4] {
  static SimStateCommand values[] = {
    SimStateCommand_Query,
    SimStateCommand_Start,
    SimStateCommand_Pause,
    SimStateCommand_Reset
  };
  return values;
}

inline const char **EnumNamesSimStateCommand() {
  static const char *names[] = {
    "Query",
    "Start",
    "Pause",
    "Reset",
    nullptr
  };
  return names;
}

inline const char *EnumNameSimStateCommand(SimStateCommand e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSimStateCommand()[index];
}

enum SimState {
  SimState_Busy = 0,
  SimState_Idle = 1,
  SimState_Active = 2,
  SimState_Paused = 3,
  SimState_MIN = SimState_Busy,
  SimState_MAX = SimState_Paused
};

inline SimState (&EnumValuesSimState())[4] {
  static SimState values[] = {
    SimState_Busy,
    SimState_Idle,
    SimState_Active,
    SimState_Paused
  };
  return values;
}

inline const char **EnumNamesSimState() {
  static const char *names[] = {
    "Busy",
    "Idle",
    "Active",
    "Paused",
    nullptr
  };
  return names;
}

inline const char *EnumNameSimState(SimState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSimState()[index];
}

/// Single common root for all engine services, containing one type per message
/// (used by both request and reply messages)
struct EngineService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SERVICE_TYPE = 4,
    VT_SERVICE = 6
  };
  EngineServiceType service_type() const {
    return static_cast<EngineServiceType>(GetField<uint8_t>(VT_SERVICE_TYPE, 0));
  }
  const void *service() const {
    return GetPointer<const void *>(VT_SERVICE);
  }
  template<typename T> const T *service_as() const;
  const SnapToGround *service_as_SnapToGround() const {
    return service_type() == EngineServiceType_SnapToGround ? static_cast<const SnapToGround *>(service()) : nullptr;
  }
  const SimStateRequest *service_as_SimStateRequest() const {
    return service_type() == EngineServiceType_SimStateRequest ? static_cast<const SimStateRequest *>(service()) : nullptr;
  }
  const SimStateReply *service_as_SimStateReply() const {
    return service_type() == EngineServiceType_SimStateReply ? static_cast<const SimStateReply *>(service()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SERVICE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SERVICE) &&
           VerifyEngineServiceType(verifier, service(), service_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SnapToGround *EngineService::service_as<SnapToGround>() const {
  return service_as_SnapToGround();
}

template<> inline const SimStateRequest *EngineService::service_as<SimStateRequest>() const {
  return service_as_SimStateRequest();
}

template<> inline const SimStateReply *EngineService::service_as<SimStateReply>() const {
  return service_as_SimStateReply();
}

struct EngineServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_service_type(EngineServiceType service_type) {
    fbb_.AddElement<uint8_t>(EngineService::VT_SERVICE_TYPE, static_cast<uint8_t>(service_type), 0);
  }
  void add_service(flatbuffers::Offset<void> service) {
    fbb_.AddOffset(EngineService::VT_SERVICE, service);
  }
  EngineServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EngineServiceBuilder &operator=(const EngineServiceBuilder &);
  flatbuffers::Offset<EngineService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EngineService>(end);
    fbb_.Required(o, EngineService::VT_SERVICE);
    return o;
  }
};

inline flatbuffers::Offset<EngineService> CreateEngineService(
    flatbuffers::FlatBufferBuilder &_fbb,
    EngineServiceType service_type = EngineServiceType_NONE,
    flatbuffers::Offset<void> service = 0) {
  EngineServiceBuilder builder_(_fbb);
  builder_.add_service(service);
  builder_.add_service_type(service_type);
  return builder_.Finish();
}

/// Snap To Ground input/output positions. (same schema for both request & reply)
struct SnapToGround FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITIONS = 4
  };
  const flatbuffers::Vector<const Vec3 *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POSITIONS) &&
           verifier.Verify(positions()) &&
           verifier.EndTable();
  }
};

struct SnapToGroundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions) {
    fbb_.AddOffset(SnapToGround::VT_POSITIONS, positions);
  }
  SnapToGroundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SnapToGroundBuilder &operator=(const SnapToGroundBuilder &);
  flatbuffers::Offset<SnapToGround> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapToGround>(end);
    fbb_.Required(o, SnapToGround::VT_POSITIONS);
    return o;
  }
};

inline flatbuffers::Offset<SnapToGround> CreateSnapToGround(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> positions = 0) {
  SnapToGroundBuilder builder_(_fbb);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<SnapToGround> CreateSnapToGroundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const Vec3 *> *positions = nullptr) {
  return RHMsg::CreateSnapToGround(
      _fbb,
      positions ? _fbb.CreateVector<const Vec3 *>(*positions) : 0);
}

/// Request change in simulation state
struct SimStateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMAND = 4
  };
  SimStateCommand command() const {
    return static_cast<SimStateCommand>(GetField<int8_t>(VT_COMMAND, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMMAND) &&
           verifier.EndTable();
  }
};

struct SimStateRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command(SimStateCommand command) {
    fbb_.AddElement<int8_t>(SimStateRequest::VT_COMMAND, static_cast<int8_t>(command), 0);
  }
  SimStateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimStateRequestBuilder &operator=(const SimStateRequestBuilder &);
  flatbuffers::Offset<SimStateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimStateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimStateRequest> CreateSimStateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    SimStateCommand command = SimStateCommand_Query) {
  SimStateRequestBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

/// Reply for SimStateRequest command
struct SimStateReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_TIME = 6
  };
  SimState state() const {
    return static_cast<SimState>(GetField<int8_t>(VT_STATE, 0));
  }
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyField<double>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct SimStateReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(SimState state) {
    fbb_.AddElement<int8_t>(SimStateReply::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_time(double time) {
    fbb_.AddElement<double>(SimStateReply::VT_TIME, time, 0.0);
  }
  SimStateReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimStateReplyBuilder &operator=(const SimStateReplyBuilder &);
  flatbuffers::Offset<SimStateReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimStateReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimStateReply> CreateSimStateReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    SimState state = SimState_Busy,
    double time = 0.0) {
  SimStateReplyBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  return builder_.Finish();
}

inline bool VerifyEngineServiceType(flatbuffers::Verifier &verifier, const void *obj, EngineServiceType type) {
  switch (type) {
    case EngineServiceType_NONE: {
      return true;
    }
    case EngineServiceType_SnapToGround: {
      auto ptr = reinterpret_cast<const SnapToGround *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EngineServiceType_SimStateRequest: {
      auto ptr = reinterpret_cast<const SimStateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EngineServiceType_SimStateReply: {
      auto ptr = reinterpret_cast<const SimStateReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEngineServiceTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEngineServiceType(
        verifier,  values->Get(i), types->GetEnum<EngineServiceType>(i))) {
      return false;
    }
  }
  return true;
}

inline const RHMsg::EngineService *GetEngineService(const void *buf) {
  return flatbuffers::GetRoot<RHMsg::EngineService>(buf);
}

inline bool VerifyEngineServiceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RHMsg::EngineService>(nullptr);
}

inline void FinishEngineServiceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<RHMsg::EngineService> root) {
  fbb.Finish(root);
}

}  // namespace RHMsg

#endif  // FLATBUFFERS_GENERATED_ENGINESERVICES_RHMSG_H_
