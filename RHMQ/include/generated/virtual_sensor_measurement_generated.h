// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VIRTUALSENSORMEASUREMENT_RHMSG_H_
#define FLATBUFFERS_GENERATED_VIRTUALSENSORMEASUREMENT_RHMSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"
#include "header_generated.h"

namespace RHMsg {

struct LaneMarkingPolynomial;

struct LaneMarkingMeasurement;

struct Sign;

struct Obstacle;

struct VirtualSensorMeasurement;

enum ObstacleType {
  ObstacleType_PEDESTRIAN = 60,
  ObstacleType_VEHICLE = 80,
  ObstacleType_UNKNOWN = 255,
  ObstacleType_MIN = ObstacleType_PEDESTRIAN,
  ObstacleType_MAX = ObstacleType_UNKNOWN
};

inline ObstacleType (&EnumValuesObstacleType())[3] {
  static ObstacleType values[] = {
    ObstacleType_PEDESTRIAN,
    ObstacleType_VEHICLE,
    ObstacleType_UNKNOWN
  };
  return values;
}

MANUALLY_ALIGNED_STRUCT(4) LaneMarkingPolynomial FLATBUFFERS_FINAL_CLASS {
 private:
  float c_0_;
  float c_1_;
  float c_2_;
  float c_3_;
  float x_min_;
  float x_max_;
  int32_t confidence_;

 public:
  LaneMarkingPolynomial() {
    memset(this, 0, sizeof(LaneMarkingPolynomial));
  }
  LaneMarkingPolynomial(const LaneMarkingPolynomial &_o) {
    memcpy(this, &_o, sizeof(LaneMarkingPolynomial));
  }
  LaneMarkingPolynomial(float _c_0, float _c_1, float _c_2, float _c_3, float _x_min, float _x_max, int32_t _confidence)
      : c_0_(flatbuffers::EndianScalar(_c_0)),
        c_1_(flatbuffers::EndianScalar(_c_1)),
        c_2_(flatbuffers::EndianScalar(_c_2)),
        c_3_(flatbuffers::EndianScalar(_c_3)),
        x_min_(flatbuffers::EndianScalar(_x_min)),
        x_max_(flatbuffers::EndianScalar(_x_max)),
        confidence_(flatbuffers::EndianScalar(_confidence)) {
  }
  float c_0() const {
    return flatbuffers::EndianScalar(c_0_);
  }
  float c_1() const {
    return flatbuffers::EndianScalar(c_1_);
  }
  float c_2() const {
    return flatbuffers::EndianScalar(c_2_);
  }
  float c_3() const {
    return flatbuffers::EndianScalar(c_3_);
  }
  float x_min() const {
    return flatbuffers::EndianScalar(x_min_);
  }
  float x_max() const {
    return flatbuffers::EndianScalar(x_max_);
  }
  int32_t confidence() const {
    return flatbuffers::EndianScalar(confidence_);
  }
};
STRUCT_END(LaneMarkingPolynomial, 28);

MANUALLY_ALIGNED_STRUCT(4) Obstacle FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  UUID uuid_;
  int8_t type_;
  int8_t padding0__;  int16_t padding1__;
  Vec3 center_;
  float width_;
  float height_;
  int32_t confidence_;

 public:
  Obstacle() {
    memset(this, 0, sizeof(Obstacle));
  }
  Obstacle(const Obstacle &_o) {
    memcpy(this, &_o, sizeof(Obstacle));
  }
  Obstacle(uint32_t _id, const UUID &_uuid, ObstacleType _type, const Vec3 &_center, float _width, float _height, int32_t _confidence)
      : id_(flatbuffers::EndianScalar(_id)),
        uuid_(_uuid),
        type_(flatbuffers::EndianScalar(static_cast<int8_t>(_type))),
        padding0__(0),
        padding1__(0),
        center_(_center),
        width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)),
        confidence_(flatbuffers::EndianScalar(_confidence)) {
    (void)padding0__;    (void)padding1__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  const UUID &uuid() const {
    return uuid_;
  }
  ObstacleType type() const {
    return static_cast<ObstacleType>(flatbuffers::EndianScalar(type_));
  }
  const Vec3 &center() const {
    return center_;
  }
  float width() const {
    return flatbuffers::EndianScalar(width_);
  }
  float height() const {
    return flatbuffers::EndianScalar(height_);
  }
  int32_t confidence() const {
    return flatbuffers::EndianScalar(confidence_);
  }
};
STRUCT_END(Obstacle, 48);

struct LaneMarkingMeasurement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEFT_LEFT_LEFT = 4,
    VT_LEFT_LEFT = 6,
    VT_LEFT = 8,
    VT_RIGHT = 10,
    VT_RIGHT_RIGHT = 12,
    VT_RIGHT_RIGHT_RIGHT = 14
  };
  const LaneMarkingPolynomial *left_left_left() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_LEFT_LEFT_LEFT);
  }
  const LaneMarkingPolynomial *left_left() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_LEFT_LEFT);
  }
  const LaneMarkingPolynomial *left() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_LEFT);
  }
  const LaneMarkingPolynomial *right() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_RIGHT);
  }
  const LaneMarkingPolynomial *right_right() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_RIGHT_RIGHT);
  }
  const LaneMarkingPolynomial *right_right_right() const {
    return GetStruct<const LaneMarkingPolynomial *>(VT_RIGHT_RIGHT_RIGHT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_LEFT_LEFT_LEFT) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_LEFT_LEFT) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_LEFT) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_RIGHT) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_RIGHT_RIGHT) &&
           VerifyField<LaneMarkingPolynomial>(verifier, VT_RIGHT_RIGHT_RIGHT) &&
           verifier.EndTable();
  }
};

struct LaneMarkingMeasurementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_left_left(const LaneMarkingPolynomial *left_left_left) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_LEFT_LEFT_LEFT, left_left_left);
  }
  void add_left_left(const LaneMarkingPolynomial *left_left) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_LEFT_LEFT, left_left);
  }
  void add_left(const LaneMarkingPolynomial *left) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_LEFT, left);
  }
  void add_right(const LaneMarkingPolynomial *right) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_RIGHT, right);
  }
  void add_right_right(const LaneMarkingPolynomial *right_right) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_RIGHT_RIGHT, right_right);
  }
  void add_right_right_right(const LaneMarkingPolynomial *right_right_right) {
    fbb_.AddStruct(LaneMarkingMeasurement::VT_RIGHT_RIGHT_RIGHT, right_right_right);
  }
  LaneMarkingMeasurementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneMarkingMeasurementBuilder &operator=(const LaneMarkingMeasurementBuilder &);
  flatbuffers::Offset<LaneMarkingMeasurement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaneMarkingMeasurement>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaneMarkingMeasurement> CreateLaneMarkingMeasurement(
    flatbuffers::FlatBufferBuilder &_fbb,
    const LaneMarkingPolynomial *left_left_left = 0,
    const LaneMarkingPolynomial *left_left = 0,
    const LaneMarkingPolynomial *left = 0,
    const LaneMarkingPolynomial *right = 0,
    const LaneMarkingPolynomial *right_right = 0,
    const LaneMarkingPolynomial *right_right_right = 0) {
  LaneMarkingMeasurementBuilder builder_(_fbb);
  builder_.add_right_right_right(right_right_right);
  builder_.add_right_right(right_right);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_left_left(left_left);
  builder_.add_left_left_left(left_left_left);
  return builder_.Finish();
}

struct Sign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_CENTER = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_CONFIDENCE = 14
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const Vec3 *center() const {
    return GetStruct<const Vec3 *>(VT_CENTER);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           VerifyField<Vec3>(verifier, VT_CENTER) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE) &&
           verifier.EndTable();
  }
};

struct SignBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Sign::VT_ID, id, 0);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Sign::VT_TYPE, type);
  }
  void add_center(const Vec3 *center) {
    fbb_.AddStruct(Sign::VT_CENTER, center);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(Sign::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(Sign::VT_HEIGHT, height, 0.0f);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(Sign::VT_CONFIDENCE, confidence, 0);
  }
  SignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignBuilder &operator=(const SignBuilder &);
  flatbuffers::Offset<Sign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sign>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sign> CreateSign(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    const Vec3 *center = 0,
    float width = 0.0f,
    float height = 0.0f,
    int32_t confidence = 0) {
  SignBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_center(center);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sign> CreateSignDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *type = nullptr,
    const Vec3 *center = 0,
    float width = 0.0f,
    float height = 0.0f,
    int32_t confidence = 0) {
  return RHMsg::CreateSign(
      _fbb,
      id,
      type ? _fbb.CreateString(type) : 0,
      center,
      width,
      height,
      confidence);
}

struct VirtualSensorMeasurement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_LANE_MARKINGS = 6,
    VT_SIGNS = 8,
    VT_OBSTACLES = 10
  };
  const HeaderData *header() const {
    return GetPointer<const HeaderData *>(VT_HEADER);
  }
  const LaneMarkingMeasurement *lane_markings() const {
    return GetPointer<const LaneMarkingMeasurement *>(VT_LANE_MARKINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Sign>> *signs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sign>> *>(VT_SIGNS);
  }
  const flatbuffers::Vector<const Obstacle *> *obstacles() const {
    return GetPointer<const flatbuffers::Vector<const Obstacle *> *>(VT_OBSTACLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_LANE_MARKINGS) &&
           verifier.VerifyTable(lane_markings()) &&
           VerifyOffset(verifier, VT_SIGNS) &&
           verifier.Verify(signs()) &&
           verifier.VerifyVectorOfTables(signs()) &&
           VerifyOffset(verifier, VT_OBSTACLES) &&
           verifier.Verify(obstacles()) &&
           verifier.EndTable();
  }
};

struct VirtualSensorMeasurementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<HeaderData> header) {
    fbb_.AddOffset(VirtualSensorMeasurement::VT_HEADER, header);
  }
  void add_lane_markings(flatbuffers::Offset<LaneMarkingMeasurement> lane_markings) {
    fbb_.AddOffset(VirtualSensorMeasurement::VT_LANE_MARKINGS, lane_markings);
  }
  void add_signs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sign>>> signs) {
    fbb_.AddOffset(VirtualSensorMeasurement::VT_SIGNS, signs);
  }
  void add_obstacles(flatbuffers::Offset<flatbuffers::Vector<const Obstacle *>> obstacles) {
    fbb_.AddOffset(VirtualSensorMeasurement::VT_OBSTACLES, obstacles);
  }
  VirtualSensorMeasurementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VirtualSensorMeasurementBuilder &operator=(const VirtualSensorMeasurementBuilder &);
  flatbuffers::Offset<VirtualSensorMeasurement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VirtualSensorMeasurement>(end);
    return o;
  }
};

inline flatbuffers::Offset<VirtualSensorMeasurement> CreateVirtualSensorMeasurement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<HeaderData> header = 0,
    flatbuffers::Offset<LaneMarkingMeasurement> lane_markings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sign>>> signs = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Obstacle *>> obstacles = 0) {
  VirtualSensorMeasurementBuilder builder_(_fbb);
  builder_.add_obstacles(obstacles);
  builder_.add_signs(signs);
  builder_.add_lane_markings(lane_markings);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<VirtualSensorMeasurement> CreateVirtualSensorMeasurementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<HeaderData> header = 0,
    flatbuffers::Offset<LaneMarkingMeasurement> lane_markings = 0,
    const std::vector<flatbuffers::Offset<Sign>> *signs = nullptr,
    const std::vector<const Obstacle *> *obstacles = nullptr) {
  return RHMsg::CreateVirtualSensorMeasurement(
      _fbb,
      header,
      lane_markings,
      signs ? _fbb.CreateVector<flatbuffers::Offset<Sign>>(*signs) : 0,
      obstacles ? _fbb.CreateVector<const Obstacle *>(*obstacles) : 0);
}

inline const RHMsg::VirtualSensorMeasurement *GetVirtualSensorMeasurement(const void *buf) {
  return flatbuffers::GetRoot<RHMsg::VirtualSensorMeasurement>(buf);
}

inline bool VerifyVirtualSensorMeasurementBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RHMsg::VirtualSensorMeasurement>(nullptr);
}

inline void FinishVirtualSensorMeasurementBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<RHMsg::VirtualSensorMeasurement> root) {
  fbb.Finish(root);
}

}  // namespace RHMsg

#endif  // FLATBUFFERS_GENERATED_VIRTUALSENSORMEASUREMENT_RHMSG_H_
