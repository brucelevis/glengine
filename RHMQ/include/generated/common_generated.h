// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_RHMSG_H_
#define FLATBUFFERS_GENERATED_COMMON_RHMSG_H_

#include "flatbuffers/flatbuffers.h"

namespace RHMsg {

struct Quat4;

struct Vec3;

struct UUID;

struct VehicleLights;

struct VehicleDashboard;

enum WheelIndex {
  WheelIndex_FRONTLEFT = 0,
  WheelIndex_FRONTRIGHT = 1,
  WheelIndex_BACKLEFT = 2,
  WheelIndex_BACKRIGHT = 3,
  WheelIndex_MIN = WheelIndex_FRONTLEFT,
  WheelIndex_MAX = WheelIndex_BACKRIGHT
};

inline WheelIndex (&EnumValuesWheelIndex())[4] {
  static WheelIndex values[] = {
    WheelIndex_FRONTLEFT,
    WheelIndex_FRONTRIGHT,
    WheelIndex_BACKLEFT,
    WheelIndex_BACKRIGHT
  };
  return values;
}

inline const char **EnumNamesWheelIndex() {
  static const char *names[] = {
    "FRONTLEFT",
    "FRONTRIGHT",
    "BACKLEFT",
    "BACKRIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameWheelIndex(WheelIndex e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWheelIndex()[index];
}

enum WheelContactMaterial {
  WheelContactMaterial_UNKNOWN = 0,
  WheelContactMaterial_ROAD = 1,
  WheelContactMaterial_PAINTED = 2,
  WheelContactMaterial_SIDEWALK = 3,
  WheelContactMaterial_METAL = 4,
  WheelContactMaterial_GRASS = 5,
  WheelContactMaterial_DIRTROAD = 6,
  WheelContactMaterial_NONE = 255,
  WheelContactMaterial_MIN = WheelContactMaterial_UNKNOWN,
  WheelContactMaterial_MAX = WheelContactMaterial_NONE
};

inline WheelContactMaterial (&EnumValuesWheelContactMaterial())[8] {
  static WheelContactMaterial values[] = {
    WheelContactMaterial_UNKNOWN,
    WheelContactMaterial_ROAD,
    WheelContactMaterial_PAINTED,
    WheelContactMaterial_SIDEWALK,
    WheelContactMaterial_METAL,
    WheelContactMaterial_GRASS,
    WheelContactMaterial_DIRTROAD,
    WheelContactMaterial_NONE
  };
  return values;
}

/// State of VI-CRT solver (enum VICRT_SOLVER_STATUS_FLAG) (OUTPUT_HW_VICRT_SOLVER_STATUS)
enum SolverState {
  SolverState_VICRT_SOLVER_STATUS_OK = 0,
  SolverState_VICRT_SOLVER_STATUS_STARTED = 1,
  SolverState_VICRT_SOLVER_STATUS_STOPPED = 2,
  SolverState_VICRT_SOLVER_STATUS_PAUSED = 3,
  SolverState_VICRT_SOLVER_STATUS_GHOSTRESYNC_REQ = 4,
  SolverState_VICRT_SOLVER_STATUS_COLLISION_DETECTED = 5,
  SolverState_VICRT_SOLVER_STATUS_AUTORESTART_5SEC = 6,
  SolverState_VICRT_SOLVER_STATUS_AUTORESTART_4SEC = 7,
  SolverState_VICRT_SOLVER_STATUS_AUTORESTART_3SEC = 8,
  SolverState_VICRT_SOLVER_STATUS_AUTORESTART_2SEC = 9,
  SolverState_VICRT_SOLVER_STATUS_AUTORESTART_1SEC = 10,
  SolverState_VICRT_SOLVER_STATUS_KO = 11,
  SolverState_MIN = SolverState_VICRT_SOLVER_STATUS_OK,
  SolverState_MAX = SolverState_VICRT_SOLVER_STATUS_KO
};

inline SolverState (&EnumValuesSolverState())[12] {
  static SolverState values[] = {
    SolverState_VICRT_SOLVER_STATUS_OK,
    SolverState_VICRT_SOLVER_STATUS_STARTED,
    SolverState_VICRT_SOLVER_STATUS_STOPPED,
    SolverState_VICRT_SOLVER_STATUS_PAUSED,
    SolverState_VICRT_SOLVER_STATUS_GHOSTRESYNC_REQ,
    SolverState_VICRT_SOLVER_STATUS_COLLISION_DETECTED,
    SolverState_VICRT_SOLVER_STATUS_AUTORESTART_5SEC,
    SolverState_VICRT_SOLVER_STATUS_AUTORESTART_4SEC,
    SolverState_VICRT_SOLVER_STATUS_AUTORESTART_3SEC,
    SolverState_VICRT_SOLVER_STATUS_AUTORESTART_2SEC,
    SolverState_VICRT_SOLVER_STATUS_AUTORESTART_1SEC,
    SolverState_VICRT_SOLVER_STATUS_KO
  };
  return values;
}

inline const char **EnumNamesSolverState() {
  static const char *names[] = {
    "VICRT_SOLVER_STATUS_OK",
    "VICRT_SOLVER_STATUS_STARTED",
    "VICRT_SOLVER_STATUS_STOPPED",
    "VICRT_SOLVER_STATUS_PAUSED",
    "VICRT_SOLVER_STATUS_GHOSTRESYNC_REQ",
    "VICRT_SOLVER_STATUS_COLLISION_DETECTED",
    "VICRT_SOLVER_STATUS_AUTORESTART_5SEC",
    "VICRT_SOLVER_STATUS_AUTORESTART_4SEC",
    "VICRT_SOLVER_STATUS_AUTORESTART_3SEC",
    "VICRT_SOLVER_STATUS_AUTORESTART_2SEC",
    "VICRT_SOLVER_STATUS_AUTORESTART_1SEC",
    "VICRT_SOLVER_STATUS_KO",
    nullptr
  };
  return names;
}

inline const char *EnumNameSolverState(SolverState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSolverState()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Quat4 FLATBUFFERS_FINAL_CLASS {
 private:
  float e_x_;
  float e_y_;
  float e_z_;
  float e_0_;

 public:
  Quat4() {
    memset(this, 0, sizeof(Quat4));
  }
  Quat4(const Quat4 &_o) {
    memcpy(this, &_o, sizeof(Quat4));
  }
  Quat4(float _e_x, float _e_y, float _e_z, float _e_0)
      : e_x_(flatbuffers::EndianScalar(_e_x)),
        e_y_(flatbuffers::EndianScalar(_e_y)),
        e_z_(flatbuffers::EndianScalar(_e_z)),
        e_0_(flatbuffers::EndianScalar(_e_0)) {
  }
  float e_x() const {
    return flatbuffers::EndianScalar(e_x_);
  }
  float e_y() const {
    return flatbuffers::EndianScalar(e_y_);
  }
  float e_z() const {
    return flatbuffers::EndianScalar(e_z_);
  }
  float e_0() const {
    return flatbuffers::EndianScalar(e_0_);
  }
};
STRUCT_END(Quat4, 16);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) UUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t a_;
  uint32_t b_;
  uint32_t c_;
  uint32_t d_;

 public:
  UUID() {
    memset(this, 0, sizeof(UUID));
  }
  UUID(const UUID &_o) {
    memcpy(this, &_o, sizeof(UUID));
  }
  UUID(uint32_t _a, uint32_t _b, uint32_t _c, uint32_t _d)
      : a_(flatbuffers::EndianScalar(_a)),
        b_(flatbuffers::EndianScalar(_b)),
        c_(flatbuffers::EndianScalar(_c)),
        d_(flatbuffers::EndianScalar(_d)) {
  }
  uint32_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  uint32_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint32_t c() const {
    return flatbuffers::EndianScalar(c_);
  }
  uint32_t d() const {
    return flatbuffers::EndianScalar(d_);
  }
};
STRUCT_END(UUID, 16);

MANUALLY_ALIGNED_STRUCT(4) VehicleLights FLATBUFFERS_FINAL_CLASS {
 private:
  float headlight_angle_degrees_;
  uint8_t low_beam_left_;
  uint8_t low_beam_right_;
  uint8_t high_beam_left_;
  uint8_t high_beam_right_;
  uint8_t turn_signal_left_;
  uint8_t turn_signal_right_;
  uint8_t fog_light_left_;
  uint8_t fog_light_right_;
  uint8_t tail_light_left_;
  uint8_t tail_light_right_;
  uint8_t brake_light_left_;
  uint8_t brake_light_right_;
  uint8_t brake_light_center_;
  uint8_t reverse_lamps_;
  uint8_t parking_lamps_;
  uint8_t daytime_running_lamps_;

 public:
  VehicleLights() {
    memset(this, 0, sizeof(VehicleLights));
  }
  VehicleLights(const VehicleLights &_o) {
    memcpy(this, &_o, sizeof(VehicleLights));
  }
  VehicleLights(float _headlight_angle_degrees, bool _low_beam_left, bool _low_beam_right, bool _high_beam_left, bool _high_beam_right, bool _turn_signal_left, bool _turn_signal_right, bool _fog_light_left, bool _fog_light_right, bool _tail_light_left, bool _tail_light_right, bool _brake_light_left, bool _brake_light_right, bool _brake_light_center, bool _reverse_lamps, bool _parking_lamps, bool _daytime_running_lamps)
      : headlight_angle_degrees_(flatbuffers::EndianScalar(_headlight_angle_degrees)),
        low_beam_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_low_beam_left))),
        low_beam_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_low_beam_right))),
        high_beam_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_high_beam_left))),
        high_beam_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_high_beam_right))),
        turn_signal_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_turn_signal_left))),
        turn_signal_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_turn_signal_right))),
        fog_light_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_fog_light_left))),
        fog_light_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_fog_light_right))),
        tail_light_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_tail_light_left))),
        tail_light_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_tail_light_right))),
        brake_light_left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_brake_light_left))),
        brake_light_right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_brake_light_right))),
        brake_light_center_(flatbuffers::EndianScalar(static_cast<uint8_t>(_brake_light_center))),
        reverse_lamps_(flatbuffers::EndianScalar(static_cast<uint8_t>(_reverse_lamps))),
        parking_lamps_(flatbuffers::EndianScalar(static_cast<uint8_t>(_parking_lamps))),
        daytime_running_lamps_(flatbuffers::EndianScalar(static_cast<uint8_t>(_daytime_running_lamps))) {
  }
  /// angle for steerable headlights
  float headlight_angle_degrees() const {
    return flatbuffers::EndianScalar(headlight_angle_degrees_);
  }
  /// low beam headlights on the left
  bool low_beam_left() const {
    return flatbuffers::EndianScalar(low_beam_left_) != 0;
  }
  /// low beam headlights on the right
  bool low_beam_right() const {
    return flatbuffers::EndianScalar(low_beam_right_) != 0;
  }
  /// high beam headlights on the left
  bool high_beam_left() const {
    return flatbuffers::EndianScalar(high_beam_left_) != 0;
  }
  /// high beam headlights on the right
  bool high_beam_right() const {
    return flatbuffers::EndianScalar(high_beam_right_) != 0;
  }
  /// left turn signal (could be split front/rear/side if needed)
  bool turn_signal_left() const {
    return flatbuffers::EndianScalar(turn_signal_left_) != 0;
  }
  /// left turn signal (could be split front/rear/side if needed)
  bool turn_signal_right() const {
    return flatbuffers::EndianScalar(turn_signal_right_) != 0;
  }
  /// left fog light (for vehicles that have them)
  bool fog_light_left() const {
    return flatbuffers::EndianScalar(fog_light_left_) != 0;
  }
  /// right fog light (for vehicles that have them)
  bool fog_light_right() const {
    return flatbuffers::EndianScalar(fog_light_right_) != 0;
  }
  /// left tail light (should be triggered along with low beams or for "parking" lights)
  bool tail_light_left() const {
    return flatbuffers::EndianScalar(tail_light_left_) != 0;
  }
  /// right tail light (should be triggered along with low beams or for "parking" lights)
  bool tail_light_right() const {
    return flatbuffers::EndianScalar(tail_light_right_) != 0;
  }
  /// higher intensity left tail light for braking
  bool brake_light_left() const {
    return flatbuffers::EndianScalar(brake_light_left_) != 0;
  }
  /// higher intensity right tail light for braking
  bool brake_light_right() const {
    return flatbuffers::EndianScalar(brake_light_right_) != 0;
  }
  /// CHMSL light for braking
  bool brake_light_center() const {
    return flatbuffers::EndianScalar(brake_light_center_) != 0;
  }
  /// reverse lights
  bool reverse_lamps() const {
    return flatbuffers::EndianScalar(reverse_lamps_) != 0;
  }
  /// parking lights
  bool parking_lamps() const {
    return flatbuffers::EndianScalar(parking_lamps_) != 0;
  }
  /// accent lights, etc. (we are also currently using for police/ambulance lights but should separate)
  bool daytime_running_lamps() const {
    return flatbuffers::EndianScalar(daytime_running_lamps_) != 0;
  }
};
STRUCT_END(VehicleLights, 20);

MANUALLY_ALIGNED_STRUCT(4) VehicleDashboard FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t vicrt_state_;
  int8_t padding0__;  int16_t padding1__;
  float steering_;
  float throttle_;
  float brake_;
  float rpm_;
  int32_t gear_;

 public:
  VehicleDashboard() {
    memset(this, 0, sizeof(VehicleDashboard));
  }
  VehicleDashboard(const VehicleDashboard &_o) {
    memcpy(this, &_o, sizeof(VehicleDashboard));
  }
  VehicleDashboard(SolverState _vicrt_state, float _steering, float _throttle, float _brake, float _rpm, int32_t _gear)
      : vicrt_state_(flatbuffers::EndianScalar(static_cast<int8_t>(_vicrt_state))),
        padding0__(0),
        padding1__(0),
        steering_(flatbuffers::EndianScalar(_steering)),
        throttle_(flatbuffers::EndianScalar(_throttle)),
        brake_(flatbuffers::EndianScalar(_brake)),
        rpm_(flatbuffers::EndianScalar(_rpm)),
        gear_(flatbuffers::EndianScalar(_gear)) {
    (void)padding0__;    (void)padding1__;
  }
  /// current state of VI-CRT solver
  SolverState vicrt_state() const {
    return static_cast<SolverState>(flatbuffers::EndianScalar(vicrt_state_));
  }
  /// steering wheel angle in degrees (clockwise is positive)
  float steering() const {
    return flatbuffers::EndianScalar(steering_);
  }
  /// throttle pedal
  float throttle() const {
    return flatbuffers::EndianScalar(throttle_);
  }
  /// brake pedal
  float brake() const {
    return flatbuffers::EndianScalar(brake_);
  }
  /// engine rpm
  float rpm() const {
    return flatbuffers::EndianScalar(rpm_);
  }
  /// current gear of transmission
  int32_t gear() const {
    return flatbuffers::EndianScalar(gear_);
  }
};
STRUCT_END(VehicleDashboard, 24);

}  // namespace RHMsg

#endif  // FLATBUFFERS_GENERATED_COMMON_RHMSG_H_
