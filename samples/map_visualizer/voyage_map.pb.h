// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: voyage_map.proto

#ifndef PROTOBUF_INCLUDED_voyage_5fmap_2eproto
#define PROTOBUF_INCLUDED_voyage_5fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_voyage_5fmap_2eproto 

namespace protobuf_voyage_5fmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_voyage_5fmap_2eproto
class Adjacency;
class AdjacencyDefaultTypeInternal;
extern AdjacencyDefaultTypeInternal _Adjacency_default_instance_;
class BoundaryAttribute;
class BoundaryAttributeDefaultTypeInternal;
extern BoundaryAttributeDefaultTypeInternal _BoundaryAttribute_default_instance_;
class Junction;
class JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Maneuver;
class ManeuverDefaultTypeInternal;
extern ManeuverDefaultTypeInternal _Maneuver_default_instance_;
class Map;
class MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class Map_JunctionsEntry_DoNotUse;
class Map_JunctionsEntry_DoNotUseDefaultTypeInternal;
extern Map_JunctionsEntry_DoNotUseDefaultTypeInternal _Map_JunctionsEntry_DoNotUse_default_instance_;
class Map_OverlapsEntry_DoNotUse;
class Map_OverlapsEntry_DoNotUseDefaultTypeInternal;
extern Map_OverlapsEntry_DoNotUseDefaultTypeInternal _Map_OverlapsEntry_DoNotUse_default_instance_;
class Map_PathsEntry_DoNotUse;
class Map_PathsEntry_DoNotUseDefaultTypeInternal;
extern Map_PathsEntry_DoNotUseDefaultTypeInternal _Map_PathsEntry_DoNotUse_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathBoundary;
class PathBoundaryDefaultTypeInternal;
extern PathBoundaryDefaultTypeInternal _PathBoundary_default_instance_;
class PathTag;
class PathTagDefaultTypeInternal;
extern PathTagDefaultTypeInternal _PathTag_default_instance_;
class PathWidth;
class PathWidthDefaultTypeInternal;
extern PathWidthDefaultTypeInternal _PathWidth_default_instance_;
class Point3d;
class Point3dDefaultTypeInternal;
extern Point3dDefaultTypeInternal _Point3d_default_instance_;
class Polygon3d;
class Polygon3dDefaultTypeInternal;
extern Polygon3dDefaultTypeInternal _Polygon3d_default_instance_;
class Polyline;
class PolylineDefaultTypeInternal;
extern PolylineDefaultTypeInternal _Polyline_default_instance_;
class RoadExtent;
class RoadExtentDefaultTypeInternal;
extern RoadExtentDefaultTypeInternal _RoadExtent_default_instance_;
class SpeedLimit;
class SpeedLimitDefaultTypeInternal;
extern SpeedLimitDefaultTypeInternal _SpeedLimit_default_instance_;
namespace google {
namespace protobuf {
template<> ::Adjacency* Arena::CreateMaybeMessage<::Adjacency>(Arena*);
template<> ::BoundaryAttribute* Arena::CreateMaybeMessage<::BoundaryAttribute>(Arena*);
template<> ::Junction* Arena::CreateMaybeMessage<::Junction>(Arena*);
template<> ::Maneuver* Arena::CreateMaybeMessage<::Maneuver>(Arena*);
template<> ::Map* Arena::CreateMaybeMessage<::Map>(Arena*);
template<> ::Map_JunctionsEntry_DoNotUse* Arena::CreateMaybeMessage<::Map_JunctionsEntry_DoNotUse>(Arena*);
template<> ::Map_OverlapsEntry_DoNotUse* Arena::CreateMaybeMessage<::Map_OverlapsEntry_DoNotUse>(Arena*);
template<> ::Map_PathsEntry_DoNotUse* Arena::CreateMaybeMessage<::Map_PathsEntry_DoNotUse>(Arena*);
template<> ::Overlap* Arena::CreateMaybeMessage<::Overlap>(Arena*);
template<> ::Path* Arena::CreateMaybeMessage<::Path>(Arena*);
template<> ::PathBoundary* Arena::CreateMaybeMessage<::PathBoundary>(Arena*);
template<> ::PathTag* Arena::CreateMaybeMessage<::PathTag>(Arena*);
template<> ::PathWidth* Arena::CreateMaybeMessage<::PathWidth>(Arena*);
template<> ::Point3d* Arena::CreateMaybeMessage<::Point3d>(Arena*);
template<> ::Polygon3d* Arena::CreateMaybeMessage<::Polygon3d>(Arena*);
template<> ::Polyline* Arena::CreateMaybeMessage<::Polyline>(Arena*);
template<> ::RoadExtent* Arena::CreateMaybeMessage<::RoadExtent>(Arena*);
template<> ::SpeedLimit* Arena::CreateMaybeMessage<::SpeedLimit>(Arena*);
}  // namespace protobuf
}  // namespace google

enum PathType {
  INTERNAL = 0,
  EXTERNAL = 1,
  COMPUTED = 2,
  PathType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PathType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PathType_IsValid(int value);
const PathType PathType_MIN = INTERNAL;
const PathType PathType_MAX = COMPUTED;
const int PathType_ARRAYSIZE = PathType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathType_descriptor();
inline const ::std::string& PathType_Name(PathType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathType_descriptor(), value);
}
inline bool PathType_Parse(
    const ::std::string& name, PathType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathType>(
    PathType_descriptor(), name, value);
}
enum TagType {
  PEDESTRIAN_CROSSING = 0,
  BICYCLE_CROSSING = 1,
  GOLF_CART_CROSSING = 2,
  STOPLINE = 3,
  WAITLINE = 4,
  WATCHLINE = 5,
  YIELDLINE = 6,
  TagType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TagType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TagType_IsValid(int value);
const TagType TagType_MIN = PEDESTRIAN_CROSSING;
const TagType TagType_MAX = YIELDLINE;
const int TagType_ARRAYSIZE = TagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TagType_descriptor();
inline const ::std::string& TagType_Name(TagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TagType_descriptor(), value);
}
inline bool TagType_Parse(
    const ::std::string& name, TagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TagType>(
    TagType_descriptor(), name, value);
}
enum ManeuverType {
  UNKNOWN = 0,
  STRAIGHT = 1,
  LEFT_TURN = 2,
  RIGHT_TURN = 3,
  LEFT_BRANCH = 4,
  RIGHT_BRANCH = 5,
  LEFT_MERGE = 6,
  RIGHT_MERGE = 7,
  PARKING_LOT = 8,
  U_TURN = 9,
  BIDIRECTIONAL = 10,
  ROUNDABOUT_ENTRY = 11,
  ROUNDABOUT_EXIT = 12,
  ManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ManeuverType_IsValid(int value);
const ManeuverType ManeuverType_MIN = UNKNOWN;
const ManeuverType ManeuverType_MAX = ROUNDABOUT_EXIT;
const int ManeuverType_ARRAYSIZE = ManeuverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ManeuverType_descriptor();
inline const ::std::string& ManeuverType_Name(ManeuverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ManeuverType_descriptor(), value);
}
inline bool ManeuverType_Parse(
    const ::std::string& name, ManeuverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ManeuverType>(
    ManeuverType_descriptor(), name, value);
}
enum BoundaryType {
  SOLID_LINE = 0,
  DASHED_LINE = 1,
  BoundaryType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BoundaryType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BoundaryType_IsValid(int value);
const BoundaryType BoundaryType_MIN = SOLID_LINE;
const BoundaryType BoundaryType_MAX = DASHED_LINE;
const int BoundaryType_ARRAYSIZE = BoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BoundaryType_descriptor();
inline const ::std::string& BoundaryType_Name(BoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BoundaryType_descriptor(), value);
}
inline bool BoundaryType_Parse(
    const ::std::string& name, BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BoundaryType>(
    BoundaryType_descriptor(), name, value);
}
// ===================================================================

class Point3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point3d) */ {
 public:
  Point3d();
  virtual ~Point3d();

  Point3d(const Point3d& from);

  inline Point3d& operator=(const Point3d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3d(Point3d&& from) noexcept
    : Point3d() {
    *this = ::std::move(from);
  }

  inline Point3d& operator=(Point3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3d* internal_default_instance() {
    return reinterpret_cast<const Point3d*>(
               &_Point3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point3d* other);
  friend void swap(Point3d& a, Point3d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3d* New() const final {
    return CreateMaybeMessage<Point3d>(NULL);
  }

  Point3d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point3d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point3d& from);
  void MergeFrom(const Point3d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:Point3d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygon3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Polygon3d) */ {
 public:
  Polygon3d();
  virtual ~Polygon3d();

  Polygon3d(const Polygon3d& from);

  inline Polygon3d& operator=(const Polygon3d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon3d(Polygon3d&& from) noexcept
    : Polygon3d() {
    *this = ::std::move(from);
  }

  inline Polygon3d& operator=(Polygon3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon3d* internal_default_instance() {
    return reinterpret_cast<const Polygon3d*>(
               &_Polygon3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Polygon3d* other);
  friend void swap(Polygon3d& a, Polygon3d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon3d* New() const final {
    return CreateMaybeMessage<Polygon3d>(NULL);
  }

  Polygon3d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polygon3d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polygon3d& from);
  void MergeFrom(const Polygon3d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon3d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Point3d points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::Point3d* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::Point3d >*
      mutable_points();
  const ::Point3d& points(int index) const;
  ::Point3d* add_points();
  const ::google::protobuf::RepeatedPtrField< ::Point3d >&
      points() const;

  // @@protoc_insertion_point(class_scope:Polygon3d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Point3d > points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polyline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Polyline) */ {
 public:
  Polyline();
  virtual ~Polyline();

  Polyline(const Polyline& from);

  inline Polyline& operator=(const Polyline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polyline(Polyline&& from) noexcept
    : Polyline() {
    *this = ::std::move(from);
  }

  inline Polyline& operator=(Polyline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polyline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polyline* internal_default_instance() {
    return reinterpret_cast<const Polyline*>(
               &_Polyline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Polyline* other);
  friend void swap(Polyline& a, Polyline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polyline* New() const final {
    return CreateMaybeMessage<Polyline>(NULL);
  }

  Polyline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polyline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polyline& from);
  void MergeFrom(const Polyline& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polyline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Point3d waypoints = 1;
  int waypoints_size() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 1;
  ::Point3d* mutable_waypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::Point3d >*
      mutable_waypoints();
  const ::Point3d& waypoints(int index) const;
  ::Point3d* add_waypoints();
  const ::google::protobuf::RepeatedPtrField< ::Point3d >&
      waypoints() const;

  // @@protoc_insertion_point(class_scope:Polyline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Point3d > waypoints_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Overlap(Overlap&& from) noexcept
    : Overlap() {
    *this = ::std::move(from);
  }

  inline Overlap& operator=(Overlap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Overlap* other);
  friend void swap(Overlap& a, Overlap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Overlap* New() const final {
    return CreateMaybeMessage<Overlap>(NULL);
  }

  Overlap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Overlap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 path_ids = 2;
  int path_ids_size() const;
  void clear_path_ids();
  static const int kPathIdsFieldNumber = 2;
  ::google::protobuf::int32 path_ids(int index) const;
  void set_path_ids(int index, ::google::protobuf::int32 value);
  void add_path_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      path_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_path_ids();

  // .Polygon3d area = 3;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 3;
  private:
  const ::Polygon3d& _internal_area() const;
  public:
  const ::Polygon3d& area() const;
  ::Polygon3d* release_area();
  ::Polygon3d* mutable_area();
  void set_allocated_area(::Polygon3d* area);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Overlap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > path_ids_;
  mutable int _path_ids_cached_byte_size_;
  ::Polygon3d* area_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Adjacency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Adjacency) */ {
 public:
  Adjacency();
  virtual ~Adjacency();

  Adjacency(const Adjacency& from);

  inline Adjacency& operator=(const Adjacency& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Adjacency(Adjacency&& from) noexcept
    : Adjacency() {
    *this = ::std::move(from);
  }

  inline Adjacency& operator=(Adjacency&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Adjacency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Adjacency* internal_default_instance() {
    return reinterpret_cast<const Adjacency*>(
               &_Adjacency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Adjacency* other);
  friend void swap(Adjacency& a, Adjacency& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Adjacency* New() const final {
    return CreateMaybeMessage<Adjacency>(NULL);
  }

  Adjacency* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Adjacency>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Adjacency& from);
  void MergeFrom(const Adjacency& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Adjacency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d start = 3;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 3;
  private:
  const ::Point3d& _internal_start() const;
  public:
  const ::Point3d& start() const;
  ::Point3d* release_start();
  ::Point3d* mutable_start();
  void set_allocated_start(::Point3d* start);

  // .Point3d end = 4;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 4;
  private:
  const ::Point3d& _internal_end() const;
  public:
  const ::Point3d& end() const;
  ::Point3d* release_end();
  ::Point3d* mutable_end();
  void set_allocated_end(::Point3d* end);

  // int32 left_path = 1;
  void clear_left_path();
  static const int kLeftPathFieldNumber = 1;
  ::google::protobuf::int32 left_path() const;
  void set_left_path(::google::protobuf::int32 value);

  // int32 right_path = 2;
  void clear_right_path();
  static const int kRightPathFieldNumber = 2;
  ::google::protobuf::int32 right_path() const;
  void set_right_path(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adjacency)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* start_;
  ::Point3d* end_;
  ::google::protobuf::int32 left_path_;
  ::google::protobuf::int32 right_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoundaryAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BoundaryAttribute) */ {
 public:
  BoundaryAttribute();
  virtual ~BoundaryAttribute();

  BoundaryAttribute(const BoundaryAttribute& from);

  inline BoundaryAttribute& operator=(const BoundaryAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundaryAttribute(BoundaryAttribute&& from) noexcept
    : BoundaryAttribute() {
    *this = ::std::move(from);
  }

  inline BoundaryAttribute& operator=(BoundaryAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundaryAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryAttribute* internal_default_instance() {
    return reinterpret_cast<const BoundaryAttribute*>(
               &_BoundaryAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BoundaryAttribute* other);
  friend void swap(BoundaryAttribute& a, BoundaryAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundaryAttribute* New() const final {
    return CreateMaybeMessage<BoundaryAttribute>(NULL);
  }

  BoundaryAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoundaryAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoundaryAttribute& from);
  void MergeFrom(const BoundaryAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundaryAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::Point3d& _internal_start() const;
  public:
  const ::Point3d& start() const;
  ::Point3d* release_start();
  ::Point3d* mutable_start();
  void set_allocated_start(::Point3d* start);

  // .Point3d end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::Point3d& _internal_end() const;
  public:
  const ::Point3d& end() const;
  ::Point3d* release_end();
  ::Point3d* mutable_end();
  void set_allocated_end(::Point3d* end);

  // .BoundaryType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::BoundaryType type() const;
  void set_type(::BoundaryType value);

  // @@protoc_insertion_point(class_scope:BoundaryAttribute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* start_;
  ::Point3d* end_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathTag) */ {
 public:
  PathTag();
  virtual ~PathTag();

  PathTag(const PathTag& from);

  inline PathTag& operator=(const PathTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathTag(PathTag&& from) noexcept
    : PathTag() {
    *this = ::std::move(from);
  }

  inline PathTag& operator=(PathTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathTag* internal_default_instance() {
    return reinterpret_cast<const PathTag*>(
               &_PathTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PathTag* other);
  friend void swap(PathTag& a, PathTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathTag* New() const final {
    return CreateMaybeMessage<PathTag>(NULL);
  }

  PathTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathTag& from);
  void MergeFrom(const PathTag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::Point3d& _internal_start() const;
  public:
  const ::Point3d& start() const;
  ::Point3d* release_start();
  ::Point3d* mutable_start();
  void set_allocated_start(::Point3d* start);

  // .Point3d end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::Point3d& _internal_end() const;
  public:
  const ::Point3d& end() const;
  ::Point3d* release_end();
  ::Point3d* mutable_end();
  void set_allocated_end(::Point3d* end);

  // .TagType tag_type = 3;
  void clear_tag_type();
  static const int kTagTypeFieldNumber = 3;
  ::TagType tag_type() const;
  void set_tag_type(::TagType value);

  // int32 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PathTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* start_;
  ::Point3d* end_;
  int tag_type_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SpeedLimit) */ {
 public:
  SpeedLimit();
  virtual ~SpeedLimit();

  SpeedLimit(const SpeedLimit& from);

  inline SpeedLimit& operator=(const SpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedLimit(SpeedLimit&& from) noexcept
    : SpeedLimit() {
    *this = ::std::move(from);
  }

  inline SpeedLimit& operator=(SpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedLimit* internal_default_instance() {
    return reinterpret_cast<const SpeedLimit*>(
               &_SpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SpeedLimit* other);
  friend void swap(SpeedLimit& a, SpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedLimit* New() const final {
    return CreateMaybeMessage<SpeedLimit>(NULL);
  }

  SpeedLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedLimit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedLimit& from);
  void MergeFrom(const SpeedLimit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::Point3d& _internal_start() const;
  public:
  const ::Point3d& start() const;
  ::Point3d* release_start();
  ::Point3d* mutable_start();
  void set_allocated_start(::Point3d* start);

  // .Point3d end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::Point3d& _internal_end() const;
  public:
  const ::Point3d& end() const;
  ::Point3d* release_end();
  ::Point3d* mutable_end();
  void set_allocated_end(::Point3d* end);

  // double speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  double speed() const;
  void set_speed(double value);

  // @@protoc_insertion_point(class_scope:SpeedLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* start_;
  ::Point3d* end_;
  double speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Maneuver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Maneuver) */ {
 public:
  Maneuver();
  virtual ~Maneuver();

  Maneuver(const Maneuver& from);

  inline Maneuver& operator=(const Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Maneuver(Maneuver&& from) noexcept
    : Maneuver() {
    *this = ::std::move(from);
  }

  inline Maneuver& operator=(Maneuver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Maneuver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Maneuver* internal_default_instance() {
    return reinterpret_cast<const Maneuver*>(
               &_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Maneuver* other);
  friend void swap(Maneuver& a, Maneuver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Maneuver* New() const final {
    return CreateMaybeMessage<Maneuver>(NULL);
  }

  Maneuver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Maneuver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Maneuver& from);
  void MergeFrom(const Maneuver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Maneuver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::Point3d& _internal_start() const;
  public:
  const ::Point3d& start() const;
  ::Point3d* release_start();
  ::Point3d* mutable_start();
  void set_allocated_start(::Point3d* start);

  // .Point3d end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  private:
  const ::Point3d& _internal_end() const;
  public:
  const ::Point3d& end() const;
  ::Point3d* release_end();
  ::Point3d* mutable_end();
  void set_allocated_end(::Point3d* end);

  // .ManeuverType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ManeuverType type() const;
  void set_type(::ManeuverType value);

  // @@protoc_insertion_point(class_scope:Maneuver)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* start_;
  ::Point3d* end_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathBoundary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathBoundary) */ {
 public:
  PathBoundary();
  virtual ~PathBoundary();

  PathBoundary(const PathBoundary& from);

  inline PathBoundary& operator=(const PathBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathBoundary(PathBoundary&& from) noexcept
    : PathBoundary() {
    *this = ::std::move(from);
  }

  inline PathBoundary& operator=(PathBoundary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathBoundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathBoundary* internal_default_instance() {
    return reinterpret_cast<const PathBoundary*>(
               &_PathBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PathBoundary* other);
  friend void swap(PathBoundary& a, PathBoundary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathBoundary* New() const final {
    return CreateMaybeMessage<PathBoundary>(NULL);
  }

  PathBoundary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathBoundary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathBoundary& from);
  void MergeFrom(const PathBoundary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathBoundary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BoundaryAttribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  ::BoundaryAttribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::BoundaryAttribute >*
      mutable_attributes();
  const ::BoundaryAttribute& attributes(int index) const;
  ::BoundaryAttribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::BoundaryAttribute >&
      attributes() const;

  // .Polyline line = 1;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 1;
  private:
  const ::Polyline& _internal_line() const;
  public:
  const ::Polyline& line() const;
  ::Polyline* release_line();
  ::Polyline* mutable_line();
  void set_allocated_line(::Polyline* line);

  // @@protoc_insertion_point(class_scope:PathBoundary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::BoundaryAttribute > attributes_;
  ::Polyline* line_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadExtent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoadExtent) */ {
 public:
  RoadExtent();
  virtual ~RoadExtent();

  RoadExtent(const RoadExtent& from);

  inline RoadExtent& operator=(const RoadExtent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadExtent(RoadExtent&& from) noexcept
    : RoadExtent() {
    *this = ::std::move(from);
  }

  inline RoadExtent& operator=(RoadExtent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadExtent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadExtent* internal_default_instance() {
    return reinterpret_cast<const RoadExtent*>(
               &_RoadExtent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RoadExtent* other);
  friend void swap(RoadExtent& a, RoadExtent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadExtent* New() const final {
    return CreateMaybeMessage<RoadExtent>(NULL);
  }

  RoadExtent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadExtent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadExtent& from);
  void MergeFrom(const RoadExtent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadExtent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Polyline left_extent = 1;
  int left_extent_size() const;
  void clear_left_extent();
  static const int kLeftExtentFieldNumber = 1;
  ::Polyline* mutable_left_extent(int index);
  ::google::protobuf::RepeatedPtrField< ::Polyline >*
      mutable_left_extent();
  const ::Polyline& left_extent(int index) const;
  ::Polyline* add_left_extent();
  const ::google::protobuf::RepeatedPtrField< ::Polyline >&
      left_extent() const;

  // repeated .Polyline right_extent = 2;
  int right_extent_size() const;
  void clear_right_extent();
  static const int kRightExtentFieldNumber = 2;
  ::Polyline* mutable_right_extent(int index);
  ::google::protobuf::RepeatedPtrField< ::Polyline >*
      mutable_right_extent();
  const ::Polyline& right_extent(int index) const;
  ::Polyline* add_right_extent();
  const ::google::protobuf::RepeatedPtrField< ::Polyline >&
      right_extent() const;

  // @@protoc_insertion_point(class_scope:RoadExtent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Polyline > left_extent_;
  ::google::protobuf::RepeatedPtrField< ::Polyline > right_extent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathWidth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PathWidth) */ {
 public:
  PathWidth();
  virtual ~PathWidth();

  PathWidth(const PathWidth& from);

  inline PathWidth& operator=(const PathWidth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathWidth(PathWidth&& from) noexcept
    : PathWidth() {
    *this = ::std::move(from);
  }

  inline PathWidth& operator=(PathWidth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathWidth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathWidth* internal_default_instance() {
    return reinterpret_cast<const PathWidth*>(
               &_PathWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PathWidth* other);
  friend void swap(PathWidth& a, PathWidth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathWidth* New() const final {
    return CreateMaybeMessage<PathWidth>(NULL);
  }

  PathWidth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathWidth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathWidth& from);
  void MergeFrom(const PathWidth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathWidth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Point3d reference_point = 1;
  bool has_reference_point() const;
  void clear_reference_point();
  static const int kReferencePointFieldNumber = 1;
  private:
  const ::Point3d& _internal_reference_point() const;
  public:
  const ::Point3d& reference_point() const;
  ::Point3d* release_reference_point();
  ::Point3d* mutable_reference_point();
  void set_allocated_reference_point(::Point3d* reference_point);

  // double left_width = 2;
  void clear_left_width();
  static const int kLeftWidthFieldNumber = 2;
  double left_width() const;
  void set_left_width(double value);

  // double right_width = 3;
  void clear_right_width();
  static const int kRightWidthFieldNumber = 3;
  double right_width() const;
  void set_right_width(double value);

  // @@protoc_insertion_point(class_scope:PathWidth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Point3d* reference_point_;
  double left_width_;
  double right_width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(Path&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Path* other);
  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(NULL);
  }

  Path* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 next_paths = 5;
  int next_paths_size() const;
  void clear_next_paths();
  static const int kNextPathsFieldNumber = 5;
  ::google::protobuf::int32 next_paths(int index) const;
  void set_next_paths(int index, ::google::protobuf::int32 value);
  void add_next_paths(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      next_paths() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_next_paths();

  // repeated int32 previous_paths = 6;
  int previous_paths_size() const;
  void clear_previous_paths();
  static const int kPreviousPathsFieldNumber = 6;
  ::google::protobuf::int32 previous_paths(int index) const;
  void set_previous_paths(int index, ::google::protobuf::int32 value);
  void add_previous_paths(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      previous_paths() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_previous_paths();

  // repeated .PathTag tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  ::PathTag* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::PathTag >*
      mutable_tags();
  const ::PathTag& tags(int index) const;
  ::PathTag* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::PathTag >&
      tags() const;

  // repeated .SpeedLimit speed_limits = 8;
  int speed_limits_size() const;
  void clear_speed_limits();
  static const int kSpeedLimitsFieldNumber = 8;
  ::SpeedLimit* mutable_speed_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::SpeedLimit >*
      mutable_speed_limits();
  const ::SpeedLimit& speed_limits(int index) const;
  ::SpeedLimit* add_speed_limits();
  const ::google::protobuf::RepeatedPtrField< ::SpeedLimit >&
      speed_limits() const;

  // repeated .Adjacency adjacencies = 11;
  int adjacencies_size() const;
  void clear_adjacencies();
  static const int kAdjacenciesFieldNumber = 11;
  ::Adjacency* mutable_adjacencies(int index);
  ::google::protobuf::RepeatedPtrField< ::Adjacency >*
      mutable_adjacencies();
  const ::Adjacency& adjacencies(int index) const;
  ::Adjacency* add_adjacencies();
  const ::google::protobuf::RepeatedPtrField< ::Adjacency >&
      adjacencies() const;

  // repeated .PathWidth path_widths = 13;
  int path_widths_size() const;
  void clear_path_widths();
  static const int kPathWidthsFieldNumber = 13;
  ::PathWidth* mutable_path_widths(int index);
  ::google::protobuf::RepeatedPtrField< ::PathWidth >*
      mutable_path_widths();
  const ::PathWidth& path_widths(int index) const;
  ::PathWidth* add_path_widths();
  const ::google::protobuf::RepeatedPtrField< ::PathWidth >&
      path_widths() const;

  // repeated .Maneuver maneuvers = 14;
  int maneuvers_size() const;
  void clear_maneuvers();
  static const int kManeuversFieldNumber = 14;
  ::Maneuver* mutable_maneuvers(int index);
  ::google::protobuf::RepeatedPtrField< ::Maneuver >*
      mutable_maneuvers();
  const ::Maneuver& maneuvers(int index) const;
  ::Maneuver* add_maneuvers();
  const ::google::protobuf::RepeatedPtrField< ::Maneuver >&
      maneuvers() const;

  // .Polygon3d area = 3;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 3;
  private:
  const ::Polygon3d& _internal_area() const;
  public:
  const ::Polygon3d& area() const;
  ::Polygon3d* release_area();
  ::Polygon3d* mutable_area();
  void set_allocated_area(::Polygon3d* area);

  // .Polyline reference_line = 4;
  bool has_reference_line() const;
  void clear_reference_line();
  static const int kReferenceLineFieldNumber = 4;
  private:
  const ::Polyline& _internal_reference_line() const;
  public:
  const ::Polyline& reference_line() const;
  ::Polyline* release_reference_line();
  ::Polyline* mutable_reference_line();
  void set_allocated_reference_line(::Polyline* reference_line);

  // .PathBoundary left_boundary = 9;
  bool has_left_boundary() const;
  void clear_left_boundary();
  static const int kLeftBoundaryFieldNumber = 9;
  private:
  const ::PathBoundary& _internal_left_boundary() const;
  public:
  const ::PathBoundary& left_boundary() const;
  ::PathBoundary* release_left_boundary();
  ::PathBoundary* mutable_left_boundary();
  void set_allocated_left_boundary(::PathBoundary* left_boundary);

  // .PathBoundary right_boundary = 10;
  bool has_right_boundary() const;
  void clear_right_boundary();
  static const int kRightBoundaryFieldNumber = 10;
  private:
  const ::PathBoundary& _internal_right_boundary() const;
  public:
  const ::PathBoundary& right_boundary() const;
  ::PathBoundary* release_right_boundary();
  ::PathBoundary* mutable_right_boundary();
  void set_allocated_right_boundary(::PathBoundary* right_boundary);

  // .RoadExtent road_extent = 12;
  bool has_road_extent() const;
  void clear_road_extent();
  static const int kRoadExtentFieldNumber = 12;
  private:
  const ::RoadExtent& _internal_road_extent() const;
  public:
  const ::RoadExtent& road_extent() const;
  ::RoadExtent* release_road_extent();
  ::RoadExtent* mutable_road_extent();
  void set_allocated_road_extent(::RoadExtent* road_extent);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .PathType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::PathType type() const;
  void set_type(::PathType value);

  // @@protoc_insertion_point(class_scope:Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > next_paths_;
  mutable int _next_paths_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > previous_paths_;
  mutable int _previous_paths_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::PathTag > tags_;
  ::google::protobuf::RepeatedPtrField< ::SpeedLimit > speed_limits_;
  ::google::protobuf::RepeatedPtrField< ::Adjacency > adjacencies_;
  ::google::protobuf::RepeatedPtrField< ::PathWidth > path_widths_;
  ::google::protobuf::RepeatedPtrField< ::Maneuver > maneuvers_;
  ::Polygon3d* area_;
  ::Polyline* reference_line_;
  ::PathBoundary* left_boundary_;
  ::PathBoundary* right_boundary_;
  ::RoadExtent* road_extent_;
  ::google::protobuf::int32 id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Junction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Junction) */ {
 public:
  Junction();
  virtual ~Junction();

  Junction(const Junction& from);

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(Junction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Junction* other);
  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction* New() const final {
    return CreateMaybeMessage<Junction>(NULL);
  }

  Junction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Junction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 path_ids = 2;
  int path_ids_size() const;
  void clear_path_ids();
  static const int kPathIdsFieldNumber = 2;
  ::google::protobuf::int32 path_ids(int index) const;
  void set_path_ids(int index, ::google::protobuf::int32 value);
  void add_path_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      path_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_path_ids();

  // .Polygon3d area = 3;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 3;
  private:
  const ::Polygon3d& _internal_area() const;
  public:
  const ::Polygon3d& area() const;
  ::Polygon3d* release_area();
  ::Polygon3d* mutable_area();
  void set_allocated_area(::Polygon3d* area);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Junction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > path_ids_;
  mutable int _path_ids_cached_byte_size_;
  ::Polygon3d* area_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Map_PathsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Map_PathsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Path,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Map_PathsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Path,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Map_PathsEntry_DoNotUse();
  Map_PathsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Map_PathsEntry_DoNotUse& other);
  static const Map_PathsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_PathsEntry_DoNotUse*>(&_Map_PathsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Map_OverlapsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Map_OverlapsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Overlap,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Map_OverlapsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Overlap,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Map_OverlapsEntry_DoNotUse();
  Map_OverlapsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Map_OverlapsEntry_DoNotUse& other);
  static const Map_OverlapsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_OverlapsEntry_DoNotUse*>(&_Map_OverlapsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Map_JunctionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Map_JunctionsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Junction,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Map_JunctionsEntry_DoNotUse, 
    ::google::protobuf::int32, ::Junction,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Map_JunctionsEntry_DoNotUse();
  Map_JunctionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Map_JunctionsEntry_DoNotUse& other);
  static const Map_JunctionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_JunctionsEntry_DoNotUse*>(&_Map_JunctionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Map) */ {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Map* other);
  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Map* New() const final {
    return CreateMaybeMessage<Map>(NULL);
  }

  Map* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Path> paths = 1;
  int paths_size() const;
  void clear_paths();
  static const int kPathsFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Path >&
      paths() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Path >*
      mutable_paths();

  // map<int32, .Overlap> overlaps = 2;
  int overlaps_size() const;
  void clear_overlaps();
  static const int kOverlapsFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Overlap >&
      overlaps() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Overlap >*
      mutable_overlaps();

  // map<int32, .Junction> junctions = 3;
  int junctions_size() const;
  void clear_junctions();
  static const int kJunctionsFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Junction >&
      junctions() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Junction >*
      mutable_junctions();

  // @@protoc_insertion_point(class_scope:Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Map_PathsEntry_DoNotUse,
      ::google::protobuf::int32, ::Path,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > paths_;
  ::google::protobuf::internal::MapField<
      Map_OverlapsEntry_DoNotUse,
      ::google::protobuf::int32, ::Overlap,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > overlaps_;
  ::google::protobuf::internal::MapField<
      Map_JunctionsEntry_DoNotUse,
      ::google::protobuf::int32, ::Junction,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > junctions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_voyage_5fmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point3d

// double x = 1;
inline void Point3d::clear_x() {
  x_ = 0;
}
inline double Point3d::x() const {
  // @@protoc_insertion_point(field_get:Point3d.x)
  return x_;
}
inline void Point3d::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Point3d.x)
}

// double y = 2;
inline void Point3d::clear_y() {
  y_ = 0;
}
inline double Point3d::y() const {
  // @@protoc_insertion_point(field_get:Point3d.y)
  return y_;
}
inline void Point3d::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Point3d.y)
}

// double z = 3;
inline void Point3d::clear_z() {
  z_ = 0;
}
inline double Point3d::z() const {
  // @@protoc_insertion_point(field_get:Point3d.z)
  return z_;
}
inline void Point3d::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Point3d.z)
}

// -------------------------------------------------------------------

// Polygon3d

// repeated .Point3d points = 1;
inline int Polygon3d::points_size() const {
  return points_.size();
}
inline void Polygon3d::clear_points() {
  points_.Clear();
}
inline ::Point3d* Polygon3d::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:Polygon3d.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Point3d >*
Polygon3d::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:Polygon3d.points)
  return &points_;
}
inline const ::Point3d& Polygon3d::points(int index) const {
  // @@protoc_insertion_point(field_get:Polygon3d.points)
  return points_.Get(index);
}
inline ::Point3d* Polygon3d::add_points() {
  // @@protoc_insertion_point(field_add:Polygon3d.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Point3d >&
Polygon3d::points() const {
  // @@protoc_insertion_point(field_list:Polygon3d.points)
  return points_;
}

// -------------------------------------------------------------------

// Polyline

// repeated .Point3d waypoints = 1;
inline int Polyline::waypoints_size() const {
  return waypoints_.size();
}
inline void Polyline::clear_waypoints() {
  waypoints_.Clear();
}
inline ::Point3d* Polyline::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:Polyline.waypoints)
  return waypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Point3d >*
Polyline::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:Polyline.waypoints)
  return &waypoints_;
}
inline const ::Point3d& Polyline::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:Polyline.waypoints)
  return waypoints_.Get(index);
}
inline ::Point3d* Polyline::add_waypoints() {
  // @@protoc_insertion_point(field_add:Polyline.waypoints)
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Point3d >&
Polyline::waypoints() const {
  // @@protoc_insertion_point(field_list:Polyline.waypoints)
  return waypoints_;
}

// -------------------------------------------------------------------

// Overlap

// int32 id = 1;
inline void Overlap::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Overlap::id() const {
  // @@protoc_insertion_point(field_get:Overlap.id)
  return id_;
}
inline void Overlap::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Overlap.id)
}

// repeated int32 path_ids = 2;
inline int Overlap::path_ids_size() const {
  return path_ids_.size();
}
inline void Overlap::clear_path_ids() {
  path_ids_.Clear();
}
inline ::google::protobuf::int32 Overlap::path_ids(int index) const {
  // @@protoc_insertion_point(field_get:Overlap.path_ids)
  return path_ids_.Get(index);
}
inline void Overlap::set_path_ids(int index, ::google::protobuf::int32 value) {
  path_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Overlap.path_ids)
}
inline void Overlap::add_path_ids(::google::protobuf::int32 value) {
  path_ids_.Add(value);
  // @@protoc_insertion_point(field_add:Overlap.path_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Overlap::path_ids() const {
  // @@protoc_insertion_point(field_list:Overlap.path_ids)
  return path_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Overlap::mutable_path_ids() {
  // @@protoc_insertion_point(field_mutable_list:Overlap.path_ids)
  return &path_ids_;
}

// .Polygon3d area = 3;
inline bool Overlap::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline void Overlap::clear_area() {
  if (GetArenaNoVirtual() == NULL && area_ != NULL) {
    delete area_;
  }
  area_ = NULL;
}
inline const ::Polygon3d& Overlap::_internal_area() const {
  return *area_;
}
inline const ::Polygon3d& Overlap::area() const {
  const ::Polygon3d* p = area_;
  // @@protoc_insertion_point(field_get:Overlap.area)
  return p != NULL ? *p : *reinterpret_cast<const ::Polygon3d*>(
      &::_Polygon3d_default_instance_);
}
inline ::Polygon3d* Overlap::release_area() {
  // @@protoc_insertion_point(field_release:Overlap.area)
  
  ::Polygon3d* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::Polygon3d* Overlap::mutable_area() {
  
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::Polygon3d>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Overlap.area)
  return area_;
}
inline void Overlap::set_allocated_area(::Polygon3d* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:Overlap.area)
}

// -------------------------------------------------------------------

// Adjacency

// int32 left_path = 1;
inline void Adjacency::clear_left_path() {
  left_path_ = 0;
}
inline ::google::protobuf::int32 Adjacency::left_path() const {
  // @@protoc_insertion_point(field_get:Adjacency.left_path)
  return left_path_;
}
inline void Adjacency::set_left_path(::google::protobuf::int32 value) {
  
  left_path_ = value;
  // @@protoc_insertion_point(field_set:Adjacency.left_path)
}

// int32 right_path = 2;
inline void Adjacency::clear_right_path() {
  right_path_ = 0;
}
inline ::google::protobuf::int32 Adjacency::right_path() const {
  // @@protoc_insertion_point(field_get:Adjacency.right_path)
  return right_path_;
}
inline void Adjacency::set_right_path(::google::protobuf::int32 value) {
  
  right_path_ = value;
  // @@protoc_insertion_point(field_set:Adjacency.right_path)
}

// .Point3d start = 3;
inline bool Adjacency::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void Adjacency::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::Point3d& Adjacency::_internal_start() const {
  return *start_;
}
inline const ::Point3d& Adjacency::start() const {
  const ::Point3d* p = start_;
  // @@protoc_insertion_point(field_get:Adjacency.start)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* Adjacency::release_start() {
  // @@protoc_insertion_point(field_release:Adjacency.start)
  
  ::Point3d* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::Point3d* Adjacency::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Adjacency.start)
  return start_;
}
inline void Adjacency::set_allocated_start(::Point3d* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:Adjacency.start)
}

// .Point3d end = 4;
inline bool Adjacency::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void Adjacency::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::Point3d& Adjacency::_internal_end() const {
  return *end_;
}
inline const ::Point3d& Adjacency::end() const {
  const ::Point3d* p = end_;
  // @@protoc_insertion_point(field_get:Adjacency.end)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* Adjacency::release_end() {
  // @@protoc_insertion_point(field_release:Adjacency.end)
  
  ::Point3d* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::Point3d* Adjacency::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Adjacency.end)
  return end_;
}
inline void Adjacency::set_allocated_end(::Point3d* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:Adjacency.end)
}

// -------------------------------------------------------------------

// BoundaryAttribute

// .Point3d start = 1;
inline bool BoundaryAttribute::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void BoundaryAttribute::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::Point3d& BoundaryAttribute::_internal_start() const {
  return *start_;
}
inline const ::Point3d& BoundaryAttribute::start() const {
  const ::Point3d* p = start_;
  // @@protoc_insertion_point(field_get:BoundaryAttribute.start)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* BoundaryAttribute::release_start() {
  // @@protoc_insertion_point(field_release:BoundaryAttribute.start)
  
  ::Point3d* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::Point3d* BoundaryAttribute::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryAttribute.start)
  return start_;
}
inline void BoundaryAttribute::set_allocated_start(::Point3d* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:BoundaryAttribute.start)
}

// .Point3d end = 2;
inline bool BoundaryAttribute::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void BoundaryAttribute::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::Point3d& BoundaryAttribute::_internal_end() const {
  return *end_;
}
inline const ::Point3d& BoundaryAttribute::end() const {
  const ::Point3d* p = end_;
  // @@protoc_insertion_point(field_get:BoundaryAttribute.end)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* BoundaryAttribute::release_end() {
  // @@protoc_insertion_point(field_release:BoundaryAttribute.end)
  
  ::Point3d* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::Point3d* BoundaryAttribute::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:BoundaryAttribute.end)
  return end_;
}
inline void BoundaryAttribute::set_allocated_end(::Point3d* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:BoundaryAttribute.end)
}

// .BoundaryType type = 3;
inline void BoundaryAttribute::clear_type() {
  type_ = 0;
}
inline ::BoundaryType BoundaryAttribute::type() const {
  // @@protoc_insertion_point(field_get:BoundaryAttribute.type)
  return static_cast< ::BoundaryType >(type_);
}
inline void BoundaryAttribute::set_type(::BoundaryType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:BoundaryAttribute.type)
}

// -------------------------------------------------------------------

// PathTag

// .Point3d start = 1;
inline bool PathTag::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void PathTag::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::Point3d& PathTag::_internal_start() const {
  return *start_;
}
inline const ::Point3d& PathTag::start() const {
  const ::Point3d* p = start_;
  // @@protoc_insertion_point(field_get:PathTag.start)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* PathTag::release_start() {
  // @@protoc_insertion_point(field_release:PathTag.start)
  
  ::Point3d* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::Point3d* PathTag::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PathTag.start)
  return start_;
}
inline void PathTag::set_allocated_start(::Point3d* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:PathTag.start)
}

// .Point3d end = 2;
inline bool PathTag::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void PathTag::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::Point3d& PathTag::_internal_end() const {
  return *end_;
}
inline const ::Point3d& PathTag::end() const {
  const ::Point3d* p = end_;
  // @@protoc_insertion_point(field_get:PathTag.end)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* PathTag::release_end() {
  // @@protoc_insertion_point(field_release:PathTag.end)
  
  ::Point3d* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::Point3d* PathTag::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PathTag.end)
  return end_;
}
inline void PathTag::set_allocated_end(::Point3d* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:PathTag.end)
}

// .TagType tag_type = 3;
inline void PathTag::clear_tag_type() {
  tag_type_ = 0;
}
inline ::TagType PathTag::tag_type() const {
  // @@protoc_insertion_point(field_get:PathTag.tag_type)
  return static_cast< ::TagType >(tag_type_);
}
inline void PathTag::set_tag_type(::TagType value) {
  
  tag_type_ = value;
  // @@protoc_insertion_point(field_set:PathTag.tag_type)
}

// int32 id = 4;
inline void PathTag::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 PathTag::id() const {
  // @@protoc_insertion_point(field_get:PathTag.id)
  return id_;
}
inline void PathTag::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:PathTag.id)
}

// -------------------------------------------------------------------

// SpeedLimit

// .Point3d start = 1;
inline bool SpeedLimit::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void SpeedLimit::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::Point3d& SpeedLimit::_internal_start() const {
  return *start_;
}
inline const ::Point3d& SpeedLimit::start() const {
  const ::Point3d* p = start_;
  // @@protoc_insertion_point(field_get:SpeedLimit.start)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* SpeedLimit::release_start() {
  // @@protoc_insertion_point(field_release:SpeedLimit.start)
  
  ::Point3d* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::Point3d* SpeedLimit::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpeedLimit.start)
  return start_;
}
inline void SpeedLimit::set_allocated_start(::Point3d* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:SpeedLimit.start)
}

// .Point3d end = 2;
inline bool SpeedLimit::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void SpeedLimit::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::Point3d& SpeedLimit::_internal_end() const {
  return *end_;
}
inline const ::Point3d& SpeedLimit::end() const {
  const ::Point3d* p = end_;
  // @@protoc_insertion_point(field_get:SpeedLimit.end)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* SpeedLimit::release_end() {
  // @@protoc_insertion_point(field_release:SpeedLimit.end)
  
  ::Point3d* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::Point3d* SpeedLimit::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpeedLimit.end)
  return end_;
}
inline void SpeedLimit::set_allocated_end(::Point3d* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:SpeedLimit.end)
}

// double speed = 3;
inline void SpeedLimit::clear_speed() {
  speed_ = 0;
}
inline double SpeedLimit::speed() const {
  // @@protoc_insertion_point(field_get:SpeedLimit.speed)
  return speed_;
}
inline void SpeedLimit::set_speed(double value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:SpeedLimit.speed)
}

// -------------------------------------------------------------------

// Maneuver

// .Point3d start = 1;
inline bool Maneuver::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void Maneuver::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::Point3d& Maneuver::_internal_start() const {
  return *start_;
}
inline const ::Point3d& Maneuver::start() const {
  const ::Point3d* p = start_;
  // @@protoc_insertion_point(field_get:Maneuver.start)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* Maneuver::release_start() {
  // @@protoc_insertion_point(field_release:Maneuver.start)
  
  ::Point3d* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::Point3d* Maneuver::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Maneuver.start)
  return start_;
}
inline void Maneuver::set_allocated_start(::Point3d* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:Maneuver.start)
}

// .Point3d end = 2;
inline bool Maneuver::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void Maneuver::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::Point3d& Maneuver::_internal_end() const {
  return *end_;
}
inline const ::Point3d& Maneuver::end() const {
  const ::Point3d* p = end_;
  // @@protoc_insertion_point(field_get:Maneuver.end)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* Maneuver::release_end() {
  // @@protoc_insertion_point(field_release:Maneuver.end)
  
  ::Point3d* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::Point3d* Maneuver::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Maneuver.end)
  return end_;
}
inline void Maneuver::set_allocated_end(::Point3d* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:Maneuver.end)
}

// .ManeuverType type = 3;
inline void Maneuver::clear_type() {
  type_ = 0;
}
inline ::ManeuverType Maneuver::type() const {
  // @@protoc_insertion_point(field_get:Maneuver.type)
  return static_cast< ::ManeuverType >(type_);
}
inline void Maneuver::set_type(::ManeuverType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Maneuver.type)
}

// -------------------------------------------------------------------

// PathBoundary

// .Polyline line = 1;
inline bool PathBoundary::has_line() const {
  return this != internal_default_instance() && line_ != NULL;
}
inline void PathBoundary::clear_line() {
  if (GetArenaNoVirtual() == NULL && line_ != NULL) {
    delete line_;
  }
  line_ = NULL;
}
inline const ::Polyline& PathBoundary::_internal_line() const {
  return *line_;
}
inline const ::Polyline& PathBoundary::line() const {
  const ::Polyline* p = line_;
  // @@protoc_insertion_point(field_get:PathBoundary.line)
  return p != NULL ? *p : *reinterpret_cast<const ::Polyline*>(
      &::_Polyline_default_instance_);
}
inline ::Polyline* PathBoundary::release_line() {
  // @@protoc_insertion_point(field_release:PathBoundary.line)
  
  ::Polyline* temp = line_;
  line_ = NULL;
  return temp;
}
inline ::Polyline* PathBoundary::mutable_line() {
  
  if (line_ == NULL) {
    auto* p = CreateMaybeMessage<::Polyline>(GetArenaNoVirtual());
    line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PathBoundary.line)
  return line_;
}
inline void PathBoundary::set_allocated_line(::Polyline* line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete line_;
  }
  if (line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    
  } else {
    
  }
  line_ = line;
  // @@protoc_insertion_point(field_set_allocated:PathBoundary.line)
}

// repeated .BoundaryAttribute attributes = 2;
inline int PathBoundary::attributes_size() const {
  return attributes_.size();
}
inline void PathBoundary::clear_attributes() {
  attributes_.Clear();
}
inline ::BoundaryAttribute* PathBoundary::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:PathBoundary.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BoundaryAttribute >*
PathBoundary::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:PathBoundary.attributes)
  return &attributes_;
}
inline const ::BoundaryAttribute& PathBoundary::attributes(int index) const {
  // @@protoc_insertion_point(field_get:PathBoundary.attributes)
  return attributes_.Get(index);
}
inline ::BoundaryAttribute* PathBoundary::add_attributes() {
  // @@protoc_insertion_point(field_add:PathBoundary.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BoundaryAttribute >&
PathBoundary::attributes() const {
  // @@protoc_insertion_point(field_list:PathBoundary.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// RoadExtent

// repeated .Polyline left_extent = 1;
inline int RoadExtent::left_extent_size() const {
  return left_extent_.size();
}
inline void RoadExtent::clear_left_extent() {
  left_extent_.Clear();
}
inline ::Polyline* RoadExtent::mutable_left_extent(int index) {
  // @@protoc_insertion_point(field_mutable:RoadExtent.left_extent)
  return left_extent_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Polyline >*
RoadExtent::mutable_left_extent() {
  // @@protoc_insertion_point(field_mutable_list:RoadExtent.left_extent)
  return &left_extent_;
}
inline const ::Polyline& RoadExtent::left_extent(int index) const {
  // @@protoc_insertion_point(field_get:RoadExtent.left_extent)
  return left_extent_.Get(index);
}
inline ::Polyline* RoadExtent::add_left_extent() {
  // @@protoc_insertion_point(field_add:RoadExtent.left_extent)
  return left_extent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Polyline >&
RoadExtent::left_extent() const {
  // @@protoc_insertion_point(field_list:RoadExtent.left_extent)
  return left_extent_;
}

// repeated .Polyline right_extent = 2;
inline int RoadExtent::right_extent_size() const {
  return right_extent_.size();
}
inline void RoadExtent::clear_right_extent() {
  right_extent_.Clear();
}
inline ::Polyline* RoadExtent::mutable_right_extent(int index) {
  // @@protoc_insertion_point(field_mutable:RoadExtent.right_extent)
  return right_extent_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Polyline >*
RoadExtent::mutable_right_extent() {
  // @@protoc_insertion_point(field_mutable_list:RoadExtent.right_extent)
  return &right_extent_;
}
inline const ::Polyline& RoadExtent::right_extent(int index) const {
  // @@protoc_insertion_point(field_get:RoadExtent.right_extent)
  return right_extent_.Get(index);
}
inline ::Polyline* RoadExtent::add_right_extent() {
  // @@protoc_insertion_point(field_add:RoadExtent.right_extent)
  return right_extent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Polyline >&
RoadExtent::right_extent() const {
  // @@protoc_insertion_point(field_list:RoadExtent.right_extent)
  return right_extent_;
}

// -------------------------------------------------------------------

// PathWidth

// .Point3d reference_point = 1;
inline bool PathWidth::has_reference_point() const {
  return this != internal_default_instance() && reference_point_ != NULL;
}
inline void PathWidth::clear_reference_point() {
  if (GetArenaNoVirtual() == NULL && reference_point_ != NULL) {
    delete reference_point_;
  }
  reference_point_ = NULL;
}
inline const ::Point3d& PathWidth::_internal_reference_point() const {
  return *reference_point_;
}
inline const ::Point3d& PathWidth::reference_point() const {
  const ::Point3d* p = reference_point_;
  // @@protoc_insertion_point(field_get:PathWidth.reference_point)
  return p != NULL ? *p : *reinterpret_cast<const ::Point3d*>(
      &::_Point3d_default_instance_);
}
inline ::Point3d* PathWidth::release_reference_point() {
  // @@protoc_insertion_point(field_release:PathWidth.reference_point)
  
  ::Point3d* temp = reference_point_;
  reference_point_ = NULL;
  return temp;
}
inline ::Point3d* PathWidth::mutable_reference_point() {
  
  if (reference_point_ == NULL) {
    auto* p = CreateMaybeMessage<::Point3d>(GetArenaNoVirtual());
    reference_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PathWidth.reference_point)
  return reference_point_;
}
inline void PathWidth::set_allocated_reference_point(::Point3d* reference_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reference_point_;
  }
  if (reference_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reference_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference_point, submessage_arena);
    }
    
  } else {
    
  }
  reference_point_ = reference_point;
  // @@protoc_insertion_point(field_set_allocated:PathWidth.reference_point)
}

// double left_width = 2;
inline void PathWidth::clear_left_width() {
  left_width_ = 0;
}
inline double PathWidth::left_width() const {
  // @@protoc_insertion_point(field_get:PathWidth.left_width)
  return left_width_;
}
inline void PathWidth::set_left_width(double value) {
  
  left_width_ = value;
  // @@protoc_insertion_point(field_set:PathWidth.left_width)
}

// double right_width = 3;
inline void PathWidth::clear_right_width() {
  right_width_ = 0;
}
inline double PathWidth::right_width() const {
  // @@protoc_insertion_point(field_get:PathWidth.right_width)
  return right_width_;
}
inline void PathWidth::set_right_width(double value) {
  
  right_width_ = value;
  // @@protoc_insertion_point(field_set:PathWidth.right_width)
}

// -------------------------------------------------------------------

// Path

// int32 id = 1;
inline void Path::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Path::id() const {
  // @@protoc_insertion_point(field_get:Path.id)
  return id_;
}
inline void Path::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Path.id)
}

// .PathType type = 2;
inline void Path::clear_type() {
  type_ = 0;
}
inline ::PathType Path::type() const {
  // @@protoc_insertion_point(field_get:Path.type)
  return static_cast< ::PathType >(type_);
}
inline void Path::set_type(::PathType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Path.type)
}

// .Polygon3d area = 3;
inline bool Path::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline void Path::clear_area() {
  if (GetArenaNoVirtual() == NULL && area_ != NULL) {
    delete area_;
  }
  area_ = NULL;
}
inline const ::Polygon3d& Path::_internal_area() const {
  return *area_;
}
inline const ::Polygon3d& Path::area() const {
  const ::Polygon3d* p = area_;
  // @@protoc_insertion_point(field_get:Path.area)
  return p != NULL ? *p : *reinterpret_cast<const ::Polygon3d*>(
      &::_Polygon3d_default_instance_);
}
inline ::Polygon3d* Path::release_area() {
  // @@protoc_insertion_point(field_release:Path.area)
  
  ::Polygon3d* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::Polygon3d* Path::mutable_area() {
  
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::Polygon3d>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Path.area)
  return area_;
}
inline void Path::set_allocated_area(::Polygon3d* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:Path.area)
}

// .Polyline reference_line = 4;
inline bool Path::has_reference_line() const {
  return this != internal_default_instance() && reference_line_ != NULL;
}
inline void Path::clear_reference_line() {
  if (GetArenaNoVirtual() == NULL && reference_line_ != NULL) {
    delete reference_line_;
  }
  reference_line_ = NULL;
}
inline const ::Polyline& Path::_internal_reference_line() const {
  return *reference_line_;
}
inline const ::Polyline& Path::reference_line() const {
  const ::Polyline* p = reference_line_;
  // @@protoc_insertion_point(field_get:Path.reference_line)
  return p != NULL ? *p : *reinterpret_cast<const ::Polyline*>(
      &::_Polyline_default_instance_);
}
inline ::Polyline* Path::release_reference_line() {
  // @@protoc_insertion_point(field_release:Path.reference_line)
  
  ::Polyline* temp = reference_line_;
  reference_line_ = NULL;
  return temp;
}
inline ::Polyline* Path::mutable_reference_line() {
  
  if (reference_line_ == NULL) {
    auto* p = CreateMaybeMessage<::Polyline>(GetArenaNoVirtual());
    reference_line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Path.reference_line)
  return reference_line_;
}
inline void Path::set_allocated_reference_line(::Polyline* reference_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reference_line_;
  }
  if (reference_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reference_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference_line, submessage_arena);
    }
    
  } else {
    
  }
  reference_line_ = reference_line;
  // @@protoc_insertion_point(field_set_allocated:Path.reference_line)
}

// repeated int32 next_paths = 5;
inline int Path::next_paths_size() const {
  return next_paths_.size();
}
inline void Path::clear_next_paths() {
  next_paths_.Clear();
}
inline ::google::protobuf::int32 Path::next_paths(int index) const {
  // @@protoc_insertion_point(field_get:Path.next_paths)
  return next_paths_.Get(index);
}
inline void Path::set_next_paths(int index, ::google::protobuf::int32 value) {
  next_paths_.Set(index, value);
  // @@protoc_insertion_point(field_set:Path.next_paths)
}
inline void Path::add_next_paths(::google::protobuf::int32 value) {
  next_paths_.Add(value);
  // @@protoc_insertion_point(field_add:Path.next_paths)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Path::next_paths() const {
  // @@protoc_insertion_point(field_list:Path.next_paths)
  return next_paths_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Path::mutable_next_paths() {
  // @@protoc_insertion_point(field_mutable_list:Path.next_paths)
  return &next_paths_;
}

// repeated int32 previous_paths = 6;
inline int Path::previous_paths_size() const {
  return previous_paths_.size();
}
inline void Path::clear_previous_paths() {
  previous_paths_.Clear();
}
inline ::google::protobuf::int32 Path::previous_paths(int index) const {
  // @@protoc_insertion_point(field_get:Path.previous_paths)
  return previous_paths_.Get(index);
}
inline void Path::set_previous_paths(int index, ::google::protobuf::int32 value) {
  previous_paths_.Set(index, value);
  // @@protoc_insertion_point(field_set:Path.previous_paths)
}
inline void Path::add_previous_paths(::google::protobuf::int32 value) {
  previous_paths_.Add(value);
  // @@protoc_insertion_point(field_add:Path.previous_paths)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Path::previous_paths() const {
  // @@protoc_insertion_point(field_list:Path.previous_paths)
  return previous_paths_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Path::mutable_previous_paths() {
  // @@protoc_insertion_point(field_mutable_list:Path.previous_paths)
  return &previous_paths_;
}

// repeated .PathTag tags = 7;
inline int Path::tags_size() const {
  return tags_.size();
}
inline void Path::clear_tags() {
  tags_.Clear();
}
inline ::PathTag* Path::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:Path.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PathTag >*
Path::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:Path.tags)
  return &tags_;
}
inline const ::PathTag& Path::tags(int index) const {
  // @@protoc_insertion_point(field_get:Path.tags)
  return tags_.Get(index);
}
inline ::PathTag* Path::add_tags() {
  // @@protoc_insertion_point(field_add:Path.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PathTag >&
Path::tags() const {
  // @@protoc_insertion_point(field_list:Path.tags)
  return tags_;
}

// repeated .SpeedLimit speed_limits = 8;
inline int Path::speed_limits_size() const {
  return speed_limits_.size();
}
inline void Path::clear_speed_limits() {
  speed_limits_.Clear();
}
inline ::SpeedLimit* Path::mutable_speed_limits(int index) {
  // @@protoc_insertion_point(field_mutable:Path.speed_limits)
  return speed_limits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SpeedLimit >*
Path::mutable_speed_limits() {
  // @@protoc_insertion_point(field_mutable_list:Path.speed_limits)
  return &speed_limits_;
}
inline const ::SpeedLimit& Path::speed_limits(int index) const {
  // @@protoc_insertion_point(field_get:Path.speed_limits)
  return speed_limits_.Get(index);
}
inline ::SpeedLimit* Path::add_speed_limits() {
  // @@protoc_insertion_point(field_add:Path.speed_limits)
  return speed_limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SpeedLimit >&
Path::speed_limits() const {
  // @@protoc_insertion_point(field_list:Path.speed_limits)
  return speed_limits_;
}

// .PathBoundary left_boundary = 9;
inline bool Path::has_left_boundary() const {
  return this != internal_default_instance() && left_boundary_ != NULL;
}
inline void Path::clear_left_boundary() {
  if (GetArenaNoVirtual() == NULL && left_boundary_ != NULL) {
    delete left_boundary_;
  }
  left_boundary_ = NULL;
}
inline const ::PathBoundary& Path::_internal_left_boundary() const {
  return *left_boundary_;
}
inline const ::PathBoundary& Path::left_boundary() const {
  const ::PathBoundary* p = left_boundary_;
  // @@protoc_insertion_point(field_get:Path.left_boundary)
  return p != NULL ? *p : *reinterpret_cast<const ::PathBoundary*>(
      &::_PathBoundary_default_instance_);
}
inline ::PathBoundary* Path::release_left_boundary() {
  // @@protoc_insertion_point(field_release:Path.left_boundary)
  
  ::PathBoundary* temp = left_boundary_;
  left_boundary_ = NULL;
  return temp;
}
inline ::PathBoundary* Path::mutable_left_boundary() {
  
  if (left_boundary_ == NULL) {
    auto* p = CreateMaybeMessage<::PathBoundary>(GetArenaNoVirtual());
    left_boundary_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Path.left_boundary)
  return left_boundary_;
}
inline void Path::set_allocated_left_boundary(::PathBoundary* left_boundary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_boundary_;
  }
  if (left_boundary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left_boundary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_boundary, submessage_arena);
    }
    
  } else {
    
  }
  left_boundary_ = left_boundary;
  // @@protoc_insertion_point(field_set_allocated:Path.left_boundary)
}

// .PathBoundary right_boundary = 10;
inline bool Path::has_right_boundary() const {
  return this != internal_default_instance() && right_boundary_ != NULL;
}
inline void Path::clear_right_boundary() {
  if (GetArenaNoVirtual() == NULL && right_boundary_ != NULL) {
    delete right_boundary_;
  }
  right_boundary_ = NULL;
}
inline const ::PathBoundary& Path::_internal_right_boundary() const {
  return *right_boundary_;
}
inline const ::PathBoundary& Path::right_boundary() const {
  const ::PathBoundary* p = right_boundary_;
  // @@protoc_insertion_point(field_get:Path.right_boundary)
  return p != NULL ? *p : *reinterpret_cast<const ::PathBoundary*>(
      &::_PathBoundary_default_instance_);
}
inline ::PathBoundary* Path::release_right_boundary() {
  // @@protoc_insertion_point(field_release:Path.right_boundary)
  
  ::PathBoundary* temp = right_boundary_;
  right_boundary_ = NULL;
  return temp;
}
inline ::PathBoundary* Path::mutable_right_boundary() {
  
  if (right_boundary_ == NULL) {
    auto* p = CreateMaybeMessage<::PathBoundary>(GetArenaNoVirtual());
    right_boundary_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Path.right_boundary)
  return right_boundary_;
}
inline void Path::set_allocated_right_boundary(::PathBoundary* right_boundary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_boundary_;
  }
  if (right_boundary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right_boundary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_boundary, submessage_arena);
    }
    
  } else {
    
  }
  right_boundary_ = right_boundary;
  // @@protoc_insertion_point(field_set_allocated:Path.right_boundary)
}

// repeated .Adjacency adjacencies = 11;
inline int Path::adjacencies_size() const {
  return adjacencies_.size();
}
inline void Path::clear_adjacencies() {
  adjacencies_.Clear();
}
inline ::Adjacency* Path::mutable_adjacencies(int index) {
  // @@protoc_insertion_point(field_mutable:Path.adjacencies)
  return adjacencies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Adjacency >*
Path::mutable_adjacencies() {
  // @@protoc_insertion_point(field_mutable_list:Path.adjacencies)
  return &adjacencies_;
}
inline const ::Adjacency& Path::adjacencies(int index) const {
  // @@protoc_insertion_point(field_get:Path.adjacencies)
  return adjacencies_.Get(index);
}
inline ::Adjacency* Path::add_adjacencies() {
  // @@protoc_insertion_point(field_add:Path.adjacencies)
  return adjacencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adjacency >&
Path::adjacencies() const {
  // @@protoc_insertion_point(field_list:Path.adjacencies)
  return adjacencies_;
}

// .RoadExtent road_extent = 12;
inline bool Path::has_road_extent() const {
  return this != internal_default_instance() && road_extent_ != NULL;
}
inline void Path::clear_road_extent() {
  if (GetArenaNoVirtual() == NULL && road_extent_ != NULL) {
    delete road_extent_;
  }
  road_extent_ = NULL;
}
inline const ::RoadExtent& Path::_internal_road_extent() const {
  return *road_extent_;
}
inline const ::RoadExtent& Path::road_extent() const {
  const ::RoadExtent* p = road_extent_;
  // @@protoc_insertion_point(field_get:Path.road_extent)
  return p != NULL ? *p : *reinterpret_cast<const ::RoadExtent*>(
      &::_RoadExtent_default_instance_);
}
inline ::RoadExtent* Path::release_road_extent() {
  // @@protoc_insertion_point(field_release:Path.road_extent)
  
  ::RoadExtent* temp = road_extent_;
  road_extent_ = NULL;
  return temp;
}
inline ::RoadExtent* Path::mutable_road_extent() {
  
  if (road_extent_ == NULL) {
    auto* p = CreateMaybeMessage<::RoadExtent>(GetArenaNoVirtual());
    road_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Path.road_extent)
  return road_extent_;
}
inline void Path::set_allocated_road_extent(::RoadExtent* road_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete road_extent_;
  }
  if (road_extent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_extent, submessage_arena);
    }
    
  } else {
    
  }
  road_extent_ = road_extent;
  // @@protoc_insertion_point(field_set_allocated:Path.road_extent)
}

// repeated .PathWidth path_widths = 13;
inline int Path::path_widths_size() const {
  return path_widths_.size();
}
inline void Path::clear_path_widths() {
  path_widths_.Clear();
}
inline ::PathWidth* Path::mutable_path_widths(int index) {
  // @@protoc_insertion_point(field_mutable:Path.path_widths)
  return path_widths_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PathWidth >*
Path::mutable_path_widths() {
  // @@protoc_insertion_point(field_mutable_list:Path.path_widths)
  return &path_widths_;
}
inline const ::PathWidth& Path::path_widths(int index) const {
  // @@protoc_insertion_point(field_get:Path.path_widths)
  return path_widths_.Get(index);
}
inline ::PathWidth* Path::add_path_widths() {
  // @@protoc_insertion_point(field_add:Path.path_widths)
  return path_widths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PathWidth >&
Path::path_widths() const {
  // @@protoc_insertion_point(field_list:Path.path_widths)
  return path_widths_;
}

// repeated .Maneuver maneuvers = 14;
inline int Path::maneuvers_size() const {
  return maneuvers_.size();
}
inline void Path::clear_maneuvers() {
  maneuvers_.Clear();
}
inline ::Maneuver* Path::mutable_maneuvers(int index) {
  // @@protoc_insertion_point(field_mutable:Path.maneuvers)
  return maneuvers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Maneuver >*
Path::mutable_maneuvers() {
  // @@protoc_insertion_point(field_mutable_list:Path.maneuvers)
  return &maneuvers_;
}
inline const ::Maneuver& Path::maneuvers(int index) const {
  // @@protoc_insertion_point(field_get:Path.maneuvers)
  return maneuvers_.Get(index);
}
inline ::Maneuver* Path::add_maneuvers() {
  // @@protoc_insertion_point(field_add:Path.maneuvers)
  return maneuvers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Maneuver >&
Path::maneuvers() const {
  // @@protoc_insertion_point(field_list:Path.maneuvers)
  return maneuvers_;
}

// -------------------------------------------------------------------

// Junction

// int32 id = 1;
inline void Junction::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Junction::id() const {
  // @@protoc_insertion_point(field_get:Junction.id)
  return id_;
}
inline void Junction::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Junction.id)
}

// repeated int32 path_ids = 2;
inline int Junction::path_ids_size() const {
  return path_ids_.size();
}
inline void Junction::clear_path_ids() {
  path_ids_.Clear();
}
inline ::google::protobuf::int32 Junction::path_ids(int index) const {
  // @@protoc_insertion_point(field_get:Junction.path_ids)
  return path_ids_.Get(index);
}
inline void Junction::set_path_ids(int index, ::google::protobuf::int32 value) {
  path_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Junction.path_ids)
}
inline void Junction::add_path_ids(::google::protobuf::int32 value) {
  path_ids_.Add(value);
  // @@protoc_insertion_point(field_add:Junction.path_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Junction::path_ids() const {
  // @@protoc_insertion_point(field_list:Junction.path_ids)
  return path_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Junction::mutable_path_ids() {
  // @@protoc_insertion_point(field_mutable_list:Junction.path_ids)
  return &path_ids_;
}

// .Polygon3d area = 3;
inline bool Junction::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline void Junction::clear_area() {
  if (GetArenaNoVirtual() == NULL && area_ != NULL) {
    delete area_;
  }
  area_ = NULL;
}
inline const ::Polygon3d& Junction::_internal_area() const {
  return *area_;
}
inline const ::Polygon3d& Junction::area() const {
  const ::Polygon3d* p = area_;
  // @@protoc_insertion_point(field_get:Junction.area)
  return p != NULL ? *p : *reinterpret_cast<const ::Polygon3d*>(
      &::_Polygon3d_default_instance_);
}
inline ::Polygon3d* Junction::release_area() {
  // @@protoc_insertion_point(field_release:Junction.area)
  
  ::Polygon3d* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::Polygon3d* Junction::mutable_area() {
  
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::Polygon3d>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Junction.area)
  return area_;
}
inline void Junction::set_allocated_area(::Polygon3d* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:Junction.area)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Map

// map<int32, .Path> paths = 1;
inline int Map::paths_size() const {
  return paths_.size();
}
inline void Map::clear_paths() {
  paths_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Path >&
Map::paths() const {
  // @@protoc_insertion_point(field_map:Map.paths)
  return paths_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Path >*
Map::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_map:Map.paths)
  return paths_.MutableMap();
}

// map<int32, .Overlap> overlaps = 2;
inline int Map::overlaps_size() const {
  return overlaps_.size();
}
inline void Map::clear_overlaps() {
  overlaps_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Overlap >&
Map::overlaps() const {
  // @@protoc_insertion_point(field_map:Map.overlaps)
  return overlaps_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Overlap >*
Map::mutable_overlaps() {
  // @@protoc_insertion_point(field_mutable_map:Map.overlaps)
  return overlaps_.MutableMap();
}

// map<int32, .Junction> junctions = 3;
inline int Map::junctions_size() const {
  return junctions_.size();
}
inline void Map::clear_junctions() {
  junctions_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Junction >&
Map::junctions() const {
  // @@protoc_insertion_point(field_map:Map.junctions)
  return junctions_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Junction >*
Map::mutable_junctions() {
  // @@protoc_insertion_point(field_mutable_map:Map.junctions)
  return junctions_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PathType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PathType>() {
  return ::PathType_descriptor();
}
template <> struct is_proto_enum< ::TagType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TagType>() {
  return ::TagType_descriptor();
}
template <> struct is_proto_enum< ::ManeuverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ManeuverType>() {
  return ::ManeuverType_descriptor();
}
template <> struct is_proto_enum< ::BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BoundaryType>() {
  return ::BoundaryType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_voyage_5fmap_2eproto
